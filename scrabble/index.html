<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scrabble</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0a; --surface: #111; --surface2: #1a1a1a;
            --border: #1e1e1e; --border2: #2a2a2a;
            --text: #e0e0e0; --text-dim: #888; --text-dimmer: #555;
            --text-heading: #ccc; --text-white: #fff;
            --cyan: #00d4ff; --cyan-bg: rgba(0,212,255,0.08);
            --red: #ef4444; --orange: #f59e0b; --green: #22c55e;
            --yellow: #fbbf24; --blue: #3b82f6;
            --tw: #ef4444; --dw: #f59e0b; --tl: #3b82f6; --dl: #22c55e;
            --center: #00d4ff;
            --tile-bg: #d4a574; --tile-text: #1a1a1a; --tile-border: #b8925a;
            --rack-bg: #1a1a1a;
        }
        [data-theme="light"] {
            --bg: #f5f5f5; --surface: #fff; --surface2: #f0f0f0;
            --border: #e0e0e0; --border2: #d0d0d0;
            --text: #333; --text-dim: #777; --text-dimmer: #aaa;
            --text-heading: #222; --text-white: #111;
            --cyan-bg: rgba(0,180,212,0.1);
            --rack-bg: #e8e8e8; --tile-bg: #e8c89e; --tile-border: #c9a46e;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg); color: var(--text);
            min-height: 100vh; min-height: 100dvh;
            transition: background 0.3s, color 0.3s; overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }
        .theme-toggle {
            position: fixed; top: 0.75rem; right: 0.75rem; z-index: 200;
            width: 36px; height: 36px; border-radius: 50%;
            border: 1px solid var(--border); background: var(--surface);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 1rem; transition: all 0.3s; color: var(--text);
        }
        .theme-toggle:hover { border-color: var(--border2); }
        .screen { display: none; }
        .screen.active { display: flex; }

        /* ===================== LOADING ===================== */
        #loadingScreen {
            flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; min-height: 100dvh; gap: 1.5rem;
        }
        #loadingScreen h1 { font-size: 2rem; font-weight: 300; color: var(--text-heading); letter-spacing: 0.08em; }
        .loading-bar { width: 200px; height: 3px; background: var(--border); border-radius: 2px; overflow: hidden; }
        .loading-bar-inner { width: 30%; height: 100%; background: var(--cyan); border-radius: 2px; animation: loadSlide 1.2s ease-in-out infinite; }
        @keyframes loadSlide { 0% { transform: translateX(-100%); } 100% { transform: translateX(400%); } }
        .loading-text { font-size: 0.82rem; color: var(--text-dim); }

        /* ===================== LOBBY ===================== */
        #lobbyScreen {
            flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; min-height: 100dvh; padding: 2rem 1rem;
        }
        .lobby { max-width: 400px; width: 100%; }
        .lobby header { text-align: center; margin-bottom: 2rem; }
        .lobby header h1 { font-size: 2.2rem; font-weight: 300; color: var(--text-heading); letter-spacing: 0.08em; }
        .lobby header .divider { width: 40px; height: 1px; background: var(--text-dimmer); margin: 1rem auto; }
        .lobby header p { font-size: 0.9rem; color: var(--text-dim); letter-spacing: 0.04em; }
        .panel {
            background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
            padding: 1.25rem; margin-bottom: 0.75rem;
        }
        .panel h2 {
            font-size: 0.72rem; font-weight: 600; text-transform: uppercase;
            letter-spacing: 0.08em; color: var(--text-dim); margin-bottom: 0.75rem;
        }
        .panel input {
            width: 100%; padding: 0.65rem 0.9rem; background: var(--surface2);
            border: 1px solid var(--border2); border-radius: 8px; color: var(--text);
            font-size: 0.9rem; outline: none; transition: border-color 0.2s;
            -webkit-appearance: none;
        }
        .panel input:focus { border-color: var(--cyan); }
        .panel input::placeholder { color: var(--text-dimmer); }
        .panel .hint { font-size: 0.7rem; color: var(--text-dimmer); margin-top: 0.35rem; }
        .timer-options { display: flex; gap: 0.6rem; }
        .timer-option {
            flex: 1; padding: 0.65rem; background: var(--surface2); border: 1px solid var(--border2);
            border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s;
            font-size: 0.85rem; color: var(--text);
        }
        .timer-option.selected { border-color: var(--cyan); background: var(--cyan-bg); color: var(--cyan); }
        .btn-row { display: flex; gap: 0.6rem; margin-top: 0.5rem; }
        .btn {
            flex: 1; padding: 0.8rem; background: transparent; border: 1px solid var(--cyan);
            border-radius: 8px; color: var(--cyan); font-size: 0.82rem; font-weight: 600;
            letter-spacing: 0.06em; text-transform: uppercase; cursor: pointer; transition: all 0.2s;
        }
        .btn:hover { background: var(--cyan-bg); }
        .btn.secondary { border-color: var(--border2); color: var(--text-dim); }
        .btn.secondary:hover { border-color: var(--text-dim); color: var(--text); }
        .lobby-error { color: var(--red); font-size: 0.78rem; margin-top: 0.5rem; text-align: center; min-height: 1.2em; }

        /* ===================== WAITING ===================== */
        #waitingScreen {
            flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; min-height: 100dvh; gap: 1rem; text-align: center; padding: 2rem;
        }
        .pin-display {
            font-family: 'SF Mono', Consolas, monospace; font-size: 3rem; font-weight: 700;
            letter-spacing: 0.3em; color: var(--cyan); margin: 1rem 0;
        }
        .waiting-msg { font-size: 0.9rem; color: var(--text-dim); }
        .waiting-dots::after { content: ''; animation: dots 1.5s steps(4,end) infinite; }
        @keyframes dots { 0% { content: ''; } 25% { content: '.'; } 50% { content: '..'; } 75% { content: '...'; } }

        /* ===================== GAME ===================== */
        #gameScreen {
            flex-direction: column; align-items: center;
            padding: 0.5rem 0.25rem 0.75rem;
            min-height: 100vh; min-height: 100dvh;
        }
        .scoreboard {
            display: flex; align-items: center; justify-content: center; gap: 0.5rem;
            width: 100%; max-width: 560px; margin-bottom: 0.25rem;
        }
        .player-info {
            display: flex; flex-direction: column; align-items: center; gap: 0.15rem;
            padding: 0.4rem 0.75rem; border-radius: 8px; background: var(--surface);
            border: 1px solid var(--border); min-width: 100px; transition: all 0.3s;
        }
        .player-info.active { border-color: var(--cyan); box-shadow: 0 0 10px rgba(0,212,255,0.1); }
        .player-info.me .p-name { color: var(--cyan); }
        .player-info .p-name { font-size: 0.68rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-dim); }
        .player-info .p-score { font-size: 1.3rem; font-weight: 700; color: var(--text-white); }
        .player-info .p-timer {
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.8rem; font-weight: 600; color: var(--text-dim); transition: color 0.3s;
        }
        .player-info.active .p-timer { color: var(--cyan); }
        .player-info .p-timer.low-time { color: var(--red); animation: pulse 1s infinite; }
        @keyframes pulse { 50% { opacity: 0.5; } }
        .score-vs { font-size: 0.68rem; color: var(--text-dimmer); font-weight: 600; text-transform: uppercase; }
        .turn-label { font-size: 0.7rem; color: var(--text-dim); text-align: center; margin-bottom: 0.35rem; }

        /* Board */
        .board {
            display: grid; grid-template-columns: repeat(15, 1fr); gap: 1px;
            width: min(96vw, 540px); aspect-ratio: 1;
            background: var(--border); border: 2px solid var(--border2);
            border-radius: 4px; padding: 1px;
            touch-action: manipulation;
        }
        .cell {
            aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
            border-radius: 1px; font-size: clamp(0.28rem, 1.5vw, 0.6rem);
            font-weight: 700; position: relative; cursor: pointer;
            transition: background 0.1s; user-select: none;
            background: var(--surface2); color: var(--text-dimmer);
            text-transform: uppercase; letter-spacing: 0.01em;
            -webkit-tap-highlight-color: transparent;
        }
        .cell.tw { background: rgba(239,68,68,0.15); color: var(--tw); }
        .cell.dw { background: rgba(245,158,11,0.12); color: var(--dw); }
        .cell.tl { background: rgba(59,130,246,0.15); color: var(--tl); }
        .cell.dl { background: rgba(34,197,94,0.12); color: var(--dl); }
        .cell.center-star { background: rgba(0,212,255,0.1); color: var(--center); font-size: clamp(0.5rem, 2.2vw, 0.9rem); }
        .cell.occupied {
            background: var(--tile-bg); color: var(--tile-text);
            font-size: clamp(0.45rem, 1.8vw, 0.85rem); font-weight: 800;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.25); cursor: default;
        }
        .cell.placed-this-turn {
            background: var(--tile-bg); color: var(--tile-text);
            font-size: clamp(0.45rem, 1.8vw, 0.85rem); font-weight: 800;
            box-shadow: 0 0 0 2px var(--cyan), 1px 1px 2px rgba(0,0,0,0.25);
            cursor: pointer; animation: placeIn 0.2s ease-out;
        }
        .cell .cell-pts {
            position: absolute; bottom: 0; right: 1px;
            font-size: clamp(0.2rem, 0.7vw, 0.38rem); font-weight: 500; opacity: 0.65;
        }
        .cell.blank-tile { font-style: italic; }
        @keyframes placeIn { 0% { transform: scale(0.5); opacity: 0.4; } 60% { transform: scale(1.08); } 100% { transform: scale(1); opacity: 1; } }
        .cell.invalid { box-shadow: inset 0 0 0 2px var(--red); animation: shake 0.35s; }
        @keyframes shake { 20% { transform: translateX(-4px); } 40% { transform: translateX(4px); } 60% { transform: translateX(-3px); } 80% { transform: translateX(3px); } }
        .cell.last-played { box-shadow: inset 0 0 0 1px var(--orange); }

        /* Rack */
        .rack-area { margin-top: 0.5rem; text-align: center; width: 100%; max-width: 540px; }
        .rack {
            display: inline-flex; gap: 4px; padding: 8px 12px;
            background: var(--rack-bg); border: 1px solid var(--border2);
            border-radius: 10px; touch-action: manipulation;
        }
        .tile {
            width: clamp(38px, 10vw, 52px); height: clamp(38px, 10vw, 52px);
            background: var(--tile-bg); border: 2px solid var(--tile-border);
            border-radius: 5px; display: flex; align-items: center; justify-content: center;
            font-size: clamp(1.1rem, 3.5vw, 1.4rem); font-weight: 800;
            color: var(--tile-text); cursor: pointer; position: relative;
            user-select: none; box-shadow: 1px 2px 3px rgba(0,0,0,0.2);
            transition: transform 0.15s, box-shadow 0.15s, border-color 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .tile:active { transform: scale(0.95); }
        .tile.selected { border-color: var(--cyan); transform: translateY(-4px); box-shadow: 0 0 10px rgba(0,212,255,0.3); }
        .tile.exchange-sel { border-color: var(--red); transform: translateY(-4px); box-shadow: 0 0 10px rgba(239,68,68,0.3); }
        .tile .tile-pts {
            position: absolute; bottom: 2px; right: 3px;
            font-size: 0.5em; font-weight: 500; opacity: 0.65;
        }
        .tile.blank { font-style: italic; color: #999; }

        /* Actions */
        .actions {
            display: flex; flex-wrap: wrap; gap: 5px; justify-content: center;
            margin-top: 0.5rem; max-width: 540px; width: 100%;
        }
        .act {
            padding: 0.55rem 0.8rem; border-radius: 6px;
            font-size: 0.7rem; font-weight: 600; text-transform: uppercase;
            letter-spacing: 0.03em; cursor: pointer; transition: all 0.2s;
            border: 1px solid var(--border2); background: var(--surface2); color: var(--text-dim);
            -webkit-tap-highlight-color: transparent;
        }
        .act:active:not(:disabled) { transform: scale(0.96); }
        .act:disabled { opacity: 0.25; cursor: not-allowed; }
        .act.primary { border-color: var(--cyan); color: var(--cyan); background: var(--cyan-bg); }
        .act.best { border-color: var(--yellow); color: var(--yellow); background: rgba(251,191,36,0.08); }
        .act.best:disabled { text-decoration: line-through; }
        .act.taunt-b { border-color: var(--orange); color: var(--orange); background: rgba(245,158,11,0.08); }
        .bag-count { font-size: 0.68rem; color: var(--text-dimmer); text-align: center; margin-top: 0.35rem; }

        /* Exchange bar */
        .exchange-bar {
            display: none; text-align: center; padding: 0.5rem; margin-top: 0.4rem;
            background: rgba(239,68,68,0.08); border: 1px solid var(--red); border-radius: 8px;
            max-width: 540px; width: 100%;
        }
        .exchange-bar.active { display: block; }
        .exchange-bar p { font-size: 0.75rem; color: var(--red); margin-bottom: 0.4rem; }

        /* Toast */
        .toast {
            position: fixed; top: 0.75rem; left: 50%; transform: translateX(-50%);
            padding: 0.6rem 1.1rem; border-radius: 8px; font-size: 0.8rem; font-weight: 600;
            z-index: 300; animation: toastIn 0.25s ease-out; max-width: 92vw; text-align: center;
        }
        .toast.success { background: rgba(34,197,94,0.15); border: 1px solid var(--green); color: var(--green); }
        .toast.error { background: rgba(239,68,68,0.15); border: 1px solid var(--red); color: var(--red); }
        .toast.info { background: rgba(0,212,255,0.15); border: 1px solid var(--cyan); color: var(--cyan); }
        @keyframes toastIn { from { opacity: 0; transform: translateX(-50%) translateY(-8px); } }

        /* Score float */
        .score-float {
            position: fixed; font-size: 1.2rem; font-weight: 800; color: var(--green);
            z-index: 250; pointer-events: none; animation: floatUp 1.2s ease-out forwards;
        }
        @keyframes floatUp { to { opacity: 0; transform: translateY(-50px); } }

        /* Taunt overlay */
        .taunt-overlay {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            z-index: 280; animation: tauntPop 0.4s ease-out; pointer-events: none;
        }
        .taunt-card {
            background: var(--surface); border: 2px solid var(--orange);
            border-radius: 16px; padding: 1.25rem 1.5rem; text-align: center;
            box-shadow: 0 8px 40px rgba(0,0,0,0.5); max-width: 300px;
        }
        .taunt-card .from { font-size: 0.68rem; font-weight: 600; color: var(--orange); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.4rem; }
        .taunt-card .msg { font-size: 1rem; color: var(--text); }
        @keyframes tauntPop { from { opacity: 0; transform: translate(-50%,-50%) scale(0.8); } to { opacity: 1; transform: translate(-50%,-50%) scale(1); } }

        /* Taunt popover */
        .taunt-pop {
            position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
            background: var(--surface); border: 1px solid var(--orange);
            border-radius: 12px; padding: 0.9rem; z-index: 150; width: 280px;
            max-width: 92vw; box-shadow: 0 8px 30px rgba(0,0,0,0.4);
        }
        .taunt-pop.hidden { display: none; }
        .taunt-pop h3 { font-size: 0.68rem; font-weight: 600; text-transform: uppercase; color: var(--orange); margin-bottom: 0.5rem; }
        .taunt-opt {
            display: block; width: 100%; text-align: left; padding: 0.4rem 0.6rem;
            background: none; border: none; color: var(--text); font-size: 0.78rem;
            cursor: pointer; border-radius: 5px; transition: background 0.1s;
        }
        .taunt-opt:hover, .taunt-opt:active { background: var(--surface2); }
        .taunt-custom { display: flex; gap: 5px; margin-top: 0.4rem; }
        .taunt-custom input {
            flex: 1; padding: 0.4rem 0.6rem; background: var(--surface2); border: 1px solid var(--border2);
            border-radius: 5px; color: var(--text); font-size: 0.78rem; outline: none;
        }
        .taunt-custom button {
            padding: 0.4rem 0.6rem; background: rgba(245,158,11,0.15); border: 1px solid var(--orange);
            border-radius: 5px; color: var(--orange); font-size: 0.7rem; font-weight: 600; cursor: pointer;
        }

        /* Blank tile modal */
        .modal-bg {
            position: fixed; inset: 0; background: rgba(10,10,10,0.8); backdrop-filter: blur(8px);
            z-index: 200; display: none; align-items: center; justify-content: center;
        }
        .modal-bg.active { display: flex; }
        .modal-box {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 12px; padding: 1.25rem; max-width: 300px; width: 90%;
        }
        .modal-box h3 { font-size: 0.82rem; font-weight: 600; color: var(--text-heading); margin-bottom: 0.8rem; text-align: center; }
        .letter-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; }
        .letter-btn {
            aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
            background: var(--tile-bg); border: 1px solid var(--tile-border);
            border-radius: 4px; font-weight: 700; font-size: 0.85rem; color: var(--tile-text);
            cursor: pointer; transition: transform 0.1s;
        }
        .letter-btn:active { transform: scale(0.92); }

        /* Game over */
        #gameOverModal {
            position: fixed; inset: 0; background: rgba(10,10,10,0.9); backdrop-filter: blur(20px);
            z-index: 250; display: none; align-items: center; justify-content: center;
        }
        #gameOverModal.active { display: flex; }
        .go-box {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 16px; padding: 2rem; max-width: 380px; width: 90%; text-align: center;
        }
        .go-box h2 { font-size: 1.3rem; font-weight: 300; color: var(--text-heading); margin-bottom: 0.4rem; }
        .go-box .winner { font-size: 1rem; color: var(--cyan); font-weight: 600; margin-bottom: 1.2rem; }
        .final-scores { display: flex; justify-content: center; gap: 2rem; margin-bottom: 1.2rem; }
        .fs-card .fs-name { font-size: 0.72rem; color: var(--text-dim); text-transform: uppercase; margin-bottom: 0.2rem; }
        .fs-card .fs-score { font-size: 2rem; font-weight: 700; color: var(--text-white); }

        .back-link {
            position: fixed; top: 0.75rem; left: 0.75rem; z-index: 200;
            color: var(--text-dim); text-decoration: none; font-size: 0.75rem;
            transition: color 0.2s;
        }
        .back-link:hover { color: var(--text); }

        .not-your-turn-overlay {
            display: none; position: fixed; bottom: 0; left: 0; right: 0;
            padding: 0.6rem; text-align: center; font-size: 0.78rem; font-weight: 600;
            color: var(--text-dim); background: var(--surface); border-top: 1px solid var(--border);
            z-index: 100;
        }
        .not-your-turn-overlay.active { display: block; }

        @media (max-width: 380px) {
            .tile { width: 36px; height: 36px; font-size: 1rem; }
            .act { padding: 0.45rem 0.55rem; font-size: 0.62rem; }
            .player-info { min-width: 80px; padding: 0.3rem 0.5rem; }
            .player-info .p-score { font-size: 1.1rem; }
        }
    </style>
</head>
<body>
    <a class="back-link" href="/">&larr; back</a>
    <button class="theme-toggle" id="themeToggle">&#x1f319;</button>

    <div id="loadingScreen" class="screen active">
        <h1>Scrabble</h1>
        <div class="loading-bar"><div class="loading-bar-inner"></div></div>
        <div class="loading-text" id="loadingText">Loading dictionary...</div>
    </div>

    <div id="lobbyScreen" class="screen">
        <div class="lobby">
            <header>
                <h1>Scrabble</h1>
                <div class="divider"></div>
                <p>two-player word duel</p>
            </header>
            <div class="panel">
                <h2>Your name</h2>
                <input type="text" id="myName" placeholder="Enter your name" maxlength="12" autocomplete="off">
            </div>
            <div class="panel">
                <h2>Timer per player</h2>
                <div class="timer-options">
                    <div class="timer-option selected" data-minutes="10">10 min</div>
                    <div class="timer-option" data-minutes="15">15 min</div>
                </div>
            </div>
            <div class="btn-row">
                <button class="btn" id="createBtn">Create Game</button>
                <button class="btn secondary" id="joinToggle">Join Game</button>
            </div>
            <div class="panel" id="joinPanel" style="display:none; margin-top:0.75rem;">
                <h2>Game PIN</h2>
                <input type="text" id="joinPin" inputmode="numeric" maxlength="4" placeholder="4-digit PIN" autocomplete="off">
                <button class="btn" id="joinBtn" style="margin-top:0.6rem;">Join</button>
            </div>
            <div class="lobby-error" id="lobbyError"></div>
        </div>
    </div>

    <div id="waitingScreen" class="screen">
        <h1 style="font-size:1.5rem;font-weight:300;color:var(--text-heading);">Game Created</h1>
        <div class="waiting-msg">Share this PIN with your opponent:</div>
        <div class="pin-display" id="pinDisplay"></div>
        <div class="waiting-msg">Waiting for opponent to join<span class="waiting-dots"></span></div>
    </div>

    <div id="gameScreen" class="screen">
        <div class="scoreboard" id="scoreboard"></div>
        <div class="turn-label" id="turnLabel"></div>
        <div class="board" id="board"></div>
        <div class="rack-area">
            <div class="rack" id="rack"></div>
        </div>
        <div class="exchange-bar" id="exchangeBar">
            <p>Select tiles to exchange, then confirm</p>
            <button class="act primary" id="confirmExchange">Confirm</button>
            <button class="act" id="cancelExchange">Cancel</button>
        </div>
        <div class="actions" id="actionsBar">
            <button class="act primary" id="submitBtn">Submit</button>
            <button class="act" id="recallBtn">Recall</button>
            <button class="act" id="shuffleBtn">Shuffle</button>
            <button class="act" id="passBtn">Pass</button>
            <button class="act" id="exchangeBtn">Exchange</button>
            <button class="act best" id="bestWordBtn">Best Word</button>
            <button class="act taunt-b" id="tauntBtn">Taunt</button>
        </div>
        <div class="bag-count" id="bagCount"></div>
        <div class="not-your-turn-overlay" id="notYourTurn">Waiting for opponent...</div>
    </div>

    <div class="taunt-pop hidden" id="tauntPop">
        <h3>Send a taunt</h3>
        <div id="tauntOpts"></div>
        <div class="taunt-custom">
            <input type="text" id="customTaunt" placeholder="Custom taunt..." maxlength="80">
            <button id="sendCustomTaunt">Send</button>
        </div>
    </div>

    <div class="modal-bg" id="blankModal">
        <div class="modal-box">
            <h3>Choose a letter</h3>
            <div class="letter-grid" id="letterGrid"></div>
        </div>
    </div>

    <div id="gameOverModal">
        <div class="go-box">
            <h2>Game Over</h2>
            <div class="winner" id="winnerText"></div>
            <div class="final-scores" id="finalScores"></div>
            <button class="btn" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
/* ============================================================
   SCRABBLE — Two-Player Firebase Multiplayer
   ============================================================ */

firebase.initializeApp({
    apiKey: "AIzaSyAbedb1guLhmnRFY_LDs5gPuhsvhW8LC1Y",
    authDomain: "popcorn-c3879.firebaseapp.com",
    databaseURL: "https://popcorn-c3879-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "popcorn-c3879",
    storageBucket: "popcorn-c3879.firebasestorage.app",
    messagingSenderId: "903922943705",
    appId: "1:903922943705:web:cd77e96de68a7a16c020c8"
});

const db = firebase.database();

// ==================== CONSTANTS ====================

const LETTER_VALUES = {
    A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,
    N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10
};
const TILE_DIST = {
    A:9,B:2,C:2,D:4,E:12,F:2,G:3,H:2,I:9,J:1,K:1,L:4,M:2,
    N:6,O:8,P:2,Q:1,R:6,S:4,T:6,U:4,V:2,W:2,X:1,Y:2,Z:1,'_':2
};
const PREMIUM = {};
([[0,0],[0,7],[0,14],[7,0],[7,14],[14,0],[14,7],[14,14]]).forEach(([r,c]) => PREMIUM[`${r},${c}`]='tw');
([[1,1],[2,2],[3,3],[4,4],[10,10],[11,11],[12,12],[13,13],[1,13],[2,12],[3,11],[4,10],[10,4],[11,3],[12,2],[13,1]]).forEach(([r,c]) => PREMIUM[`${r},${c}`]='dw');
([[1,5],[1,9],[5,1],[5,5],[5,9],[5,13],[9,1],[9,5],[9,9],[9,13],[13,5],[13,9]]).forEach(([r,c]) => PREMIUM[`${r},${c}`]='tl');
([[0,3],[0,11],[2,6],[2,8],[3,0],[3,7],[3,14],[6,2],[6,6],[6,8],[6,12],[7,3],[7,11],[8,2],[8,6],[8,8],[8,12],[11,0],[11,7],[11,14],[12,6],[12,8],[14,3],[14,11]]).forEach(([r,c]) => PREMIUM[`${r},${c}`]='dl');
const PREM_LABEL = { tw:'TW', dw:'DW', tl:'TL', dl:'DL' };
const TAUNTS = [
    "Is that the best you've got?",
    "My grandma plays better.",
    "I've seen better words in a fortune cookie.",
    "You're making this too easy.",
    "That word? Really?",
    "I'm not even trying yet.",
    "Better luck next turn.",
    "Triple word incoming..."
];

// ==================== STATE ====================

let DICT = null, TRIE = null;
let gameRef = null, gamePin = null, mySlot = -1; // 0 or 1
let localPlaced = [], selectedTile = -1, exchangeMode = false, exchangeSel = [];
let pendingBlank = null, bestWordUsed = false;
let timerInterval = null, lastTimerSync = 0;
let gameData = null; // synced from Firebase
let unsubGame = null;

// ==================== TRIE ====================

class TN { constructor() { this.c = {}; this.w = false; } }

function buildTrie(words) {
    const root = new TN();
    for (const w of words) {
        let n = root;
        for (const ch of w) { if (!n.c[ch]) n.c[ch] = new TN(); n = n.c[ch]; }
        n.w = true;
    }
    return root;
}

async function loadDict() {
    try {
        const r = await fetch('./words.txt');
        if (!r.ok) throw 0;
        const t = await r.text();
        const words = t.trim().split(/\r?\n/).map(w => w.trim().toUpperCase()).filter(Boolean);
        DICT = new Set(words);
        TRIE = buildTrie(words);
        showScreen('lobbyScreen');
    } catch(e) {
        document.getElementById('loadingText').textContent = 'Error loading dictionary. Refresh to retry.';
        document.getElementById('loadingText').style.color = 'var(--red)';
    }
}

// ==================== HELPERS ====================

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}

function toast(msg, type='info', ms=2500) {
    document.querySelectorAll('.toast').forEach(t => t.remove());
    const el = document.createElement('div');
    el.className = `toast ${type}`; el.textContent = msg;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), ms);
}

function scoreFloat(score, x, y) {
    const el = document.createElement('div');
    el.className = 'score-float'; el.textContent = `+${score}`;
    el.style.left = x+'px'; el.style.top = y+'px';
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1200);
}

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

function shuffle(a) { for (let i=a.length-1;i>0;i--) { const j=Math.random()*i+1|0; [a[i],a[j]]=[a[j],a[i]]; } }

function fmtTime(s) { return `${s/60|0}:${(s%60+'').padStart(2,'0')}`; }

function genPin() { return String(1000 + Math.random()*9000|0); }

function makeBag() {
    const bag = [];
    for (const [l,n] of Object.entries(TILE_DIST)) for (let i=0;i<n;i++) bag.push(l);
    shuffle(bag);
    return bag;
}

// ==================== LOBBY ====================

function initLobby() {
    document.querySelectorAll('.timer-option').forEach(o => {
        o.addEventListener('click', () => {
            document.querySelectorAll('.timer-option').forEach(x => x.classList.remove('selected'));
            o.classList.add('selected');
        });
    });

    document.getElementById('joinToggle').addEventListener('click', () => {
        const p = document.getElementById('joinPanel');
        p.style.display = p.style.display === 'none' ? 'block' : 'none';
    });

    document.getElementById('createBtn').addEventListener('click', createGame);
    document.getElementById('joinBtn').addEventListener('click', joinGame);
}

async function createGame() {
    const name = document.getElementById('myName').value.trim() || 'Player 1';
    const minutes = parseInt(document.querySelector('.timer-option.selected').dataset.minutes);
    const err = document.getElementById('lobbyError');
    err.textContent = '';

    const pin = genPin();
    const bag = makeBag();
    const rack0 = bag.splice(-7);
    const rack1 = bag.splice(-7);

    const data = {
        pin,
        timerMinutes: minutes,
        players: [
            { name, score: 0, timerRemaining: minutes * 60, bestWordUsed: false },
            { name: '', score: 0, timerRemaining: minutes * 60, bestWordUsed: false }
        ],
        racks: [rack0, rack1],
        bag,
        board: {}, // sparse: "r,c" -> { letter, isBlank }
        currentPlayer: 0,
        turnNumber: 1,
        consecutivePasses: 0,
        firstMove: true,
        timedOut: [false, false],
        phase: 'waiting', // waiting -> playing -> gameover
        lastMovePositions: [],
        taunt: null, // { from, text, target } — appears on target's screen
        createdAt: firebase.database.ServerValue.TIMESTAMP
    };

    try {
        gameRef = db.ref('scrabble_games/' + pin);
        // Check PIN not in use
        const snap = await gameRef.once('value');
        if (snap.exists()) {
            const existing = snap.val();
            // Allow reuse if old game (>2 hours)
            if (existing.createdAt && Date.now() - existing.createdAt < 7200000) {
                err.textContent = 'PIN already in use. Try again.';
                return;
            }
        }
        await gameRef.set(data);
        gamePin = pin;
        mySlot = 0;
        bestWordUsed = false;
        document.getElementById('pinDisplay').textContent = pin;
        showScreen('waitingScreen');
        subscribeToGame();
    } catch(e) {
        err.textContent = 'Error creating game. Check your connection.';
        console.error(e);
    }
}

async function joinGame() {
    const name = document.getElementById('myName').value.trim() || 'Player 2';
    const pin = document.getElementById('joinPin').value.trim();
    const err = document.getElementById('lobbyError');
    err.textContent = '';

    if (!/^\d{4}$/.test(pin)) { err.textContent = 'Enter a 4-digit PIN.'; return; }

    try {
        gameRef = db.ref('scrabble_games/' + pin);
        const snap = await gameRef.once('value');
        if (!snap.exists()) { err.textContent = 'Game not found.'; return; }
        const data = snap.val();
        if (data.phase !== 'waiting') { err.textContent = 'Game already started.'; return; }

        await gameRef.update({
            'players/1/name': name,
            phase: 'playing'
        });

        gamePin = pin;
        mySlot = 1;
        bestWordUsed = data.players[1].bestWordUsed || false;
        showScreen('gameScreen');
        subscribeToGame();
    } catch(e) {
        err.textContent = 'Error joining game.';
        console.error(e);
    }
}

// ==================== FIREBASE SYNC ====================

function subscribeToGame() {
    if (unsubGame) unsubGame();
    unsubGame = () => gameRef.off('value');

    gameRef.on('value', snap => {
        const data = snap.val();
        if (!data) return;
        const prevData = gameData;
        gameData = data;

        // Player 2 joined — move creator to game screen
        if (mySlot === 0 && data.phase === 'playing' && (!prevData || prevData.phase === 'waiting')) {
            showScreen('gameScreen');
        }

        // Check for incoming taunt
        if (data.taunt && data.taunt.target === mySlot) {
            showTauntOverlay(data.taunt.from, data.taunt.text);
            gameRef.update({ taunt: null });
        }

        // Check game over
        if (data.phase === 'gameover') {
            clearInterval(timerInterval);
            showGameOver(data);
            return;
        }

        // Sync bestWordUsed from server
        if (data.players && data.players[mySlot]) {
            bestWordUsed = data.players[mySlot].bestWordUsed || false;
        }

        renderAll();
        manageTimer();
    });
}

function manageTimer() {
    clearInterval(timerInterval);
    if (!gameData || gameData.phase !== 'playing') return;
    if (gameData.currentPlayer !== mySlot) return;
    if (gameData.timedOut && gameData.timedOut[mySlot]) return;

    timerInterval = setInterval(() => {
        if (!gameData) return;
        const p = gameData.players[mySlot];
        if (p.timerRemaining <= 0) {
            clearInterval(timerInterval);
            gameRef.update({
                [`players/${mySlot}/timerRemaining`]: 0,
                [`timedOut/${mySlot}`]: true
            });
            recallTiles();
            toast(`Time's up!`, 'error');
            // Auto-pass
            setTimeout(() => doPass(), 1000);
            return;
        }
        // Decrement locally and sync every 5 seconds
        gameData.players[mySlot].timerRemaining--;
        renderScoreboard();
        lastTimerSync++;
        if (lastTimerSync >= 5) {
            lastTimerSync = 0;
            gameRef.update({ [`players/${mySlot}/timerRemaining`]: gameData.players[mySlot].timerRemaining });
        }
    }, 1000);
}

// ==================== RENDERING ====================

function renderAll() {
    if (!gameData) return;
    renderScoreboard();
    renderBoard();
    renderRack();
    renderActions();
    renderBagCount();
    renderTurnOverlay();
}

function isMyTurn() {
    return gameData && gameData.phase === 'playing' && gameData.currentPlayer === mySlot && !gameData.timedOut?.[mySlot];
}

function renderTurnOverlay() {
    const el = document.getElementById('notYourTurn');
    if (!isMyTurn() && gameData?.phase === 'playing') {
        const oppName = gameData.players[1 - mySlot]?.name || 'Opponent';
        el.textContent = `${oppName}'s turn...`;
        el.classList.add('active');
    } else {
        el.classList.remove('active');
    }
}

function renderScoreboard() {
    const sb = document.getElementById('scoreboard');
    sb.innerHTML = '';
    if (!gameData) return;

    [0, 1].forEach((pi, idx) => {
        const p = gameData.players[pi];
        if (!p) return;
        const isActive = gameData.currentPlayer === pi;
        const isMe = pi === mySlot;
        const lowTime = p.timerRemaining <= 60 && isActive;
        const div = document.createElement('div');
        div.className = 'player-info' + (isActive ? ' active' : '') + (isMe ? ' me' : '');
        div.innerHTML = `
            <div class="p-name">${esc(p.name || 'Waiting...')}</div>
            <div class="p-score">${p.score}</div>
            <div class="p-timer${lowTime ? ' low-time' : ''}">${fmtTime(p.timerRemaining)}</div>
        `;
        sb.appendChild(div);
        if (idx === 0) { const vs = document.createElement('div'); vs.className='score-vs'; vs.textContent='vs'; sb.appendChild(vs); }
    });

    const cp = gameData.players[gameData.currentPlayer];
    document.getElementById('turnLabel').textContent = cp
        ? `Turn ${gameData.turnNumber} — ${cp.name}'s move`
        : '';
}

function renderBoard() {
    const el = document.getElementById('board');
    el.innerHTML = '';
    if (!gameData) return;

    const boardMap = gameData.board || {};
    const lastMoves = new Set((gameData.lastMovePositions || []).map(p => `${p.row},${p.col}`));

    for (let r = 0; r < 15; r++) {
        for (let c = 0; c < 15; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = r;
            cell.dataset.col = c;

            const key = `${r},${c}`;
            const tile = boardMap[key];
            const placedNow = localPlaced.find(p => p.row === r && p.col === c);

            if (placedNow) {
                cell.classList.add('placed-this-turn');
                if (placedNow.originalLetter === '_') cell.classList.add('blank-tile');
                cell.textContent = placedNow.displayLetter;
                if (placedNow.originalLetter !== '_' && LETTER_VALUES[placedNow.displayLetter] != null) {
                    const pts = document.createElement('span');
                    pts.className = 'cell-pts'; pts.textContent = LETTER_VALUES[placedNow.displayLetter];
                    cell.appendChild(pts);
                }
            } else if (tile) {
                cell.classList.add('occupied');
                if (tile.isBlank) cell.classList.add('blank-tile');
                if (lastMoves.has(key)) cell.classList.add('last-played');
                cell.textContent = tile.letter;
                if (!tile.isBlank && LETTER_VALUES[tile.letter] != null) {
                    const pts = document.createElement('span');
                    pts.className = 'cell-pts'; pts.textContent = LETTER_VALUES[tile.letter];
                    cell.appendChild(pts);
                }
            } else {
                const prem = PREMIUM[key];
                if (r === 7 && c === 7) { cell.classList.add('center-star'); cell.textContent = '\u2605'; }
                else if (prem) { cell.classList.add(prem); cell.textContent = PREM_LABEL[prem]; }
            }

            cell.addEventListener('click', () => onCellClick(r, c));
            el.appendChild(cell);
        }
    }
}

function onCellClick(r, c) {
    if (!isMyTurn() || exchangeMode) return;

    // Return placed tile to rack (just remove from localPlaced, effectiveRack recalculates)
    const pi = localPlaced.findIndex(p => p.row === r && p.col === c);
    if (pi !== -1) {
        localPlaced.splice(pi, 1);
        selectedTile = -1;
        renderBoard(); renderRack();
        return;
    }

    // Place selected tile
    if (selectedTile >= 0 && !getBoardTile(r, c) && !localPlaced.find(p => p.row === r && p.col === c)) {
        const rack = effectiveRack();
        const letter = rack[selectedTile];
        if (letter === '_') {
            pendingBlank = { row: r, col: c, rackIndex: selectedTile };
            showBlankModal();
            return;
        }
        doPlace(r, c, letter, letter);
    }
}

function doPlace(r, c, displayLetter, originalLetter) {
    localPlaced.push({ row: r, col: c, displayLetter, originalLetter, rackIndex: selectedTile });
    selectedTile = -1;
    renderBoard(); renderRack();
}

function myRack() {
    return gameData?.racks?.[mySlot] || [];
}

// Compute the effective rack: server rack minus tiles currently placed on board locally
function effectiveRack() {
    const serverRack = (gameData?.racks?.[mySlot] || []).slice();
    // Remove letters that are in localPlaced (consume from serverRack copy)
    for (const p of localPlaced) {
        const idx = serverRack.indexOf(p.originalLetter);
        if (idx >= 0) serverRack.splice(idx, 1);
    }
    return serverRack;
}

function getBoardTile(r, c) {
    return gameData?.board?.[`${r},${c}`] || null;
}

function showBlankModal() {
    const modal = document.getElementById('blankModal');
    const grid = document.getElementById('letterGrid');
    grid.innerHTML = '';
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').forEach(l => {
        const b = document.createElement('button');
        b.className = 'letter-btn'; b.textContent = l;
        b.addEventListener('click', () => {
            modal.classList.remove('active');
            if (pendingBlank) { doPlace(pendingBlank.row, pendingBlank.col, l, '_'); pendingBlank = null; }
        });
        grid.appendChild(b);
    });
    modal.classList.add('active');
}

function renderRack() {
    const el = document.getElementById('rack');
    el.innerHTML = '';
    const rack = effectiveRack();

    rack.forEach((letter, i) => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        if (i === selectedTile) tile.classList.add('selected');
        if (exchangeMode && exchangeSel.includes(i)) tile.classList.add('exchange-sel');
        if (letter === '_') { tile.classList.add('blank'); tile.textContent = ''; }
        else {
            tile.textContent = letter;
            const pts = document.createElement('span');
            pts.className = 'tile-pts'; pts.textContent = LETTER_VALUES[letter];
            tile.appendChild(pts);
        }
        tile.addEventListener('click', () => onTileClick(i));
        el.appendChild(tile);
    });
}

function onTileClick(i) {
    if (!isMyTurn()) return;
    if (exchangeMode) {
        const idx = exchangeSel.indexOf(i);
        if (idx >= 0) exchangeSel.splice(idx, 1); else exchangeSel.push(i);
        renderRack(); return;
    }
    selectedTile = selectedTile === i ? -1 : i;
    renderRack();
}

function renderActions() {
    const my = isMyTurn();
    document.getElementById('submitBtn').disabled = !my;
    document.getElementById('recallBtn').disabled = !my;
    document.getElementById('passBtn').disabled = !my;
    document.getElementById('exchangeBtn').disabled = !my || (gameData?.bag?.length || 0) < 1;
    document.getElementById('shuffleBtn').disabled = !my;
    document.getElementById('bestWordBtn').disabled = !my || bestWordUsed;
    document.getElementById('tauntBtn').disabled = !my;
}

function renderBagCount() {
    document.getElementById('bagCount').textContent = `Tiles in bag: ${gameData?.bag?.length || 0}`;
}

// ==================== WORD SUBMISSION ====================

async function submitWord() {
    if (!isMyTurn() || localPlaced.length === 0) { toast('Place some tiles first', 'error'); return; }

    const boardMap = gameData.board || {};
    // Build a virtual board for validation
    const vBoard = Array.from({length:15}, () => Array(15).fill(null));
    for (const [k,v] of Object.entries(boardMap)) {
        const [r,c] = k.split(',').map(Number);
        vBoard[r][c] = v;
    }
    for (const p of localPlaced) {
        vBoard[p.row][p.col] = { letter: p.displayLetter, isBlank: p.originalLetter === '_' };
    }

    // Validate placement
    const rows = [...new Set(localPlaced.map(p => p.row))];
    const cols = [...new Set(localPlaced.map(p => p.col))];
    const sameRow = rows.length === 1, sameCol = cols.length === 1;

    if (!sameRow && !sameCol) { toast('Tiles must be in one row or column', 'error'); hlInvalid(); return; }

    if (gameData.firstMove) {
        if (!localPlaced.some(p => p.row===7 && p.col===7)) { toast('First word must cover the center', 'error'); hlInvalid(); return; }
        if (localPlaced.length < 2) { toast('First word must be at least 2 letters', 'error'); hlInvalid(); return; }
    } else {
        const adj = localPlaced.some(p => {
            return [[0,1],[0,-1],[1,0],[-1,0]].some(([dr,dc]) => {
                const nr=p.row+dr, nc=p.col+dc;
                if (nr<0||nr>14||nc<0||nc>14) return false;
                const t = boardMap[`${nr},${nc}`];
                return t && !localPlaced.some(pp => pp.row===nr && pp.col===nc);
            });
        });
        if (!adj) { toast('Must connect to existing tiles', 'error'); hlInvalid(); return; }
    }

    // Check gaps
    if (sameRow) {
        const r = rows[0], minC = Math.min(...localPlaced.map(p=>p.col)), maxC = Math.max(...localPlaced.map(p=>p.col));
        for (let c=minC;c<=maxC;c++) if (!vBoard[r][c]) { toast('No gaps allowed', 'error'); hlInvalid(); return; }
    } else {
        const c = cols[0], minR = Math.min(...localPlaced.map(p=>p.row)), maxR = Math.max(...localPlaced.map(p=>p.row));
        for (let r=minR;r<=maxR;r++) if (!vBoard[r][c]) { toast('No gaps allowed', 'error'); hlInvalid(); return; }
    }

    // Extract words
    const words = extractWordsVB(vBoard, localPlaced, sameRow);
    if (words.length === 0) { toast('No word formed', 'error'); hlInvalid(); return; }

    const invalid = words.filter(w => w.length >= 2 && !DICT.has(w.map(c=>c.letter).join('')));
    if (invalid.length) {
        toast(`Invalid: ${invalid.map(w=>w.map(c=>c.letter).join('')).join(', ')}`, 'error', 3500);
        hlInvalid(); return;
    }

    // Score
    const newPos = new Set(localPlaced.map(p=>`${p.row},${p.col}`));
    let total = 0;
    for (const w of words) {
        if (w.length < 2) continue;
        let ws = 0, wm = 1;
        for (const cell of w) {
            const lv = cell.isBlank ? 0 : (LETTER_VALUES[cell.letter]||0);
            let ls = lv;
            if (newPos.has(`${cell.row},${cell.col}`)) {
                const pr = PREMIUM[`${cell.row},${cell.col}`];
                if (pr==='dl') ls*=2; if (pr==='tl') ls*=3;
                if (pr==='dw') wm*=2; if (pr==='tw') wm*=3;
            }
            ws += ls;
        }
        total += ws * wm;
    }
    if (localPlaced.length === 7) total += 50;

    // Build updates
    const updates = {};
    const newBoard = { ...(gameData.board || {}) };
    for (const p of localPlaced) {
        newBoard[`${p.row},${p.col}`] = { letter: p.displayLetter, isBlank: p.originalLetter === '_' };
    }
    updates.board = newBoard;
    updates[`players/${mySlot}/score`] = (gameData.players[mySlot].score || 0) + total;
    updates[`players/${mySlot}/timerRemaining`] = gameData.players[mySlot].timerRemaining;
    updates.consecutivePasses = 0;
    updates.firstMove = false;
    updates.lastMovePositions = localPlaced.map(p => ({ row: p.row, col: p.col }));

    // Draw tiles from bag — use effectiveRack (server rack minus placed tiles)
    const rack = effectiveRack();
    const bag = (gameData.bag || []).slice();
    const draw = Math.min(localPlaced.length, bag.length);
    for (let i = 0; i < draw; i++) rack.push(bag.pop());
    updates[`racks/${mySlot}`] = rack;
    updates.bag = bag;

    // Check game end
    if (rack.length === 0 && bag.length === 0) {
        updates.phase = 'gameover';
    } else {
        updates.currentPlayer = 1 - mySlot;
        updates.turnNumber = (gameData.turnNumber || 1) + 1;
    }

    // Show float
    const bEl = document.getElementById('board');
    const rect = bEl.getBoundingClientRect();
    const avgR = localPlaced.reduce((s,p)=>s+p.row,0)/localPlaced.length;
    const avgC = localPlaced.reduce((s,p)=>s+p.col,0)/localPlaced.length;
    scoreFloat(total, rect.left+avgC*rect.width/15, rect.top+avgR*rect.width/15);

    const wordStrs = words.filter(w=>w.length>=2).map(w=>w.map(c=>c.letter).join(''));
    toast(`${wordStrs.join(', ')} — +${total}`, 'success', 3000);

    localPlaced = []; selectedTile = -1;

    try { await gameRef.update(updates); } catch(e) { toast('Sync error', 'error'); console.error(e); }
}

function extractWordsVB(vBoard, placed, sameRow) {
    const words = [];
    if (sameRow) {
        const r = placed[0].row;
        const main = getWordVB(vBoard, r, placed[0].col, 'across');
        if (main.length >= 2) words.push(main);
        for (const p of placed) {
            const cross = getWordVB(vBoard, p.row, p.col, 'down');
            if (cross.length >= 2) words.push(cross);
        }
    } else {
        const c = placed[0].col;
        const main = getWordVB(vBoard, placed[0].row, c, 'down');
        if (main.length >= 2) words.push(main);
        for (const p of placed) {
            const cross = getWordVB(vBoard, p.row, p.col, 'across');
            if (cross.length >= 2) words.push(cross);
        }
    }
    return words;
}

function getWordVB(vBoard, row, col, dir) {
    const cells = [];
    let r=row, c=col;
    const dr=dir==='down'?1:0, dc=dir==='across'?1:0;
    while (r-dr>=0 && c-dc>=0 && vBoard[r-dr][c-dc]) { r-=dr; c-=dc; }
    while (r>=0 && r<15 && c>=0 && c<15 && vBoard[r][c]) {
        const t = vBoard[r][c];
        cells.push({ row:r, col:c, letter:t.letter, isBlank:t.isBlank||false });
        r+=dr; c+=dc;
    }
    return cells;
}

function hlInvalid() {
    localPlaced.forEach(p => {
        const cell = document.querySelector(`.cell[data-row="${p.row}"][data-col="${p.col}"]`);
        if (cell) { cell.classList.add('invalid'); setTimeout(() => cell.classList.remove('invalid'), 600); }
    });
}

// ==================== ACTIONS ====================

function recallTiles() {
    localPlaced = []; selectedTile = -1;
    renderBoard(); renderRack();
}

async function doPass() {
    if (localPlaced.length > 0) recallTiles();
    const passes = (gameData.consecutivePasses || 0) + 1;
    const updates = {
        consecutivePasses: passes,
        currentPlayer: 1 - mySlot,
        turnNumber: (gameData.turnNumber || 1) + 1,
        lastMovePositions: [],
        [`players/${mySlot}/timerRemaining`]: gameData.players[mySlot].timerRemaining,
        [`racks/${mySlot}`]: effectiveRack()
    };
    if (passes >= 6) updates.phase = 'gameover';
    toast(`${gameData.players[mySlot].name} passed`, 'info');
    try { await gameRef.update(updates); } catch(e) { console.error(e); }
}

async function doExchange() {
    if (exchangeSel.length === 0) { toast('Select tiles to exchange', 'error'); return; }
    const rack = effectiveRack();
    const bag = (gameData.bag || []).slice();
    const sorted = [...exchangeSel].sort((a,b) => b-a);
    const returned = sorted.map(i => rack[i]);
    sorted.forEach(i => rack.splice(i, 1));
    const draw = Math.min(returned.length, bag.length);
    for (let i=0; i<draw; i++) rack.push(bag.pop());
    returned.forEach(t => bag.push(t));
    shuffle(bag);

    exitExchange();
    toast(`Exchanged ${returned.length} tile${returned.length>1?'s':''}`, 'info');
    try {
        await gameRef.update({
            [`racks/${mySlot}`]: rack,
            bag,
            currentPlayer: 1 - mySlot,
            turnNumber: (gameData.turnNumber||1) + 1,
            consecutivePasses: 0,
            lastMovePositions: [],
            [`players/${mySlot}/timerRemaining`]: gameData.players[mySlot].timerRemaining
        });
    } catch(e) { console.error(e); }
}

function enterExchange() {
    if (localPlaced.length > 0) recallTiles();
    exchangeMode = true; exchangeSel = [];
    document.getElementById('exchangeBar').classList.add('active');
    document.getElementById('actionsBar').style.display = 'none';
    renderRack();
}
function exitExchange() {
    exchangeMode = false; exchangeSel = [];
    document.getElementById('exchangeBar').classList.remove('active');
    document.getElementById('actionsBar').style.display = '';
    renderRack();
}

function initActions() {
    document.getElementById('submitBtn').addEventListener('click', submitWord);
    document.getElementById('recallBtn').addEventListener('click', () => { recallTiles(); renderBoard(); renderRack(); });
    document.getElementById('shuffleBtn').addEventListener('click', () => { shuffle(myRack()); renderRack(); });
    document.getElementById('passBtn').addEventListener('click', doPass);
    document.getElementById('exchangeBtn').addEventListener('click', enterExchange);
    document.getElementById('confirmExchange').addEventListener('click', doExchange);
    document.getElementById('cancelExchange').addEventListener('click', exitExchange);
    document.getElementById('bestWordBtn').addEventListener('click', playBestWord);
    document.getElementById('tauntBtn').addEventListener('click', toggleTaunt);
    document.getElementById('playAgainBtn').addEventListener('click', () => {
        document.getElementById('gameOverModal').classList.remove('active');
        if (unsubGame) { unsubGame(); unsubGame = null; }
        gameRef = null; gameData = null;
        showScreen('lobbyScreen');
    });
}

// ==================== TAUNT ====================

function toggleTaunt() {
    document.getElementById('tauntPop').classList.toggle('hidden');
    if (!document.getElementById('tauntPop').classList.contains('hidden')) renderTauntOpts();
}

function renderTauntOpts() {
    const c = document.getElementById('tauntOpts');
    c.innerHTML = '';
    TAUNTS.forEach(t => {
        const b = document.createElement('button');
        b.className = 'taunt-opt'; b.textContent = t;
        b.addEventListener('click', () => sendTaunt(t));
        c.appendChild(b);
    });
}

async function sendTaunt(text) {
    document.getElementById('tauntPop').classList.add('hidden');
    document.getElementById('customTaunt').value = '';
    toast('Taunt sent!', 'info', 1500);
    try {
        await gameRef.update({
            taunt: { from: gameData.players[mySlot].name, text, target: 1 - mySlot }
        });
    } catch(e) { console.error(e); }
}

function showTauntOverlay(from, text) {
    const el = document.createElement('div');
    el.className = 'taunt-overlay';
    el.innerHTML = `<div class="taunt-card"><div class="from">${esc(from)} says:</div><div class="msg">${esc(text)}</div></div>`;
    document.body.appendChild(el);
    setTimeout(() => { el.style.transition = 'opacity 0.5s'; el.style.opacity = '0'; setTimeout(() => el.remove(), 500); }, 3000);
}

function initTaunt() {
    document.getElementById('sendCustomTaunt').addEventListener('click', () => {
        const t = document.getElementById('customTaunt').value.trim();
        if (t) sendTaunt(t);
    });
    document.getElementById('customTaunt').addEventListener('keydown', e => {
        if (e.key === 'Enter') { const t = e.target.value.trim(); if (t) sendTaunt(t); }
    });
    document.addEventListener('click', e => {
        const pop = document.getElementById('tauntPop');
        const btn = document.getElementById('tauntBtn');
        if (!pop.contains(e.target) && e.target !== btn) pop.classList.add('hidden');
    });
}

// ==================== BEST WORD ====================

async function playBestWord() {
    if (!isMyTurn() || bestWordUsed) return;
    if (localPlaced.length > 0) { recallTiles(); renderBoard(); renderRack(); }

    toast('Finding best word...', 'info', 2000);

    setTimeout(async () => {
        // Build virtual board
        const vBoard = Array.from({length:15}, () => Array(15).fill(null));
        const boardMap = gameData.board || {};
        for (const [k,v] of Object.entries(boardMap)) {
            const [r,c] = k.split(',').map(Number);
            vBoard[r][c] = v;
        }

        const rack = effectiveRack();
        const move = findBestMoveVB(vBoard, rack, gameData.firstMove);

        if (!move || move.score === 0) {
            toast('No valid moves found — use not consumed', 'error', 2500);
            return;
        }

        // Place tiles with animation — find index in effectiveRack each time
        move.tiles.forEach((t, i) => {
            setTimeout(() => {
                const currentRack = effectiveRack();
                const idx = currentRack.indexOf(t.rackLetter);
                if (idx >= 0) {
                    selectedTile = idx;
                    doPlace(t.row, t.col, t.displayLetter, t.rackLetter);
                }
                if (i === move.tiles.length - 1) {
                    setTimeout(async () => {
                        // Mark best word as used only after placing — submitWord will handle the rest
                        bestWordUsed = true;
                        await gameRef.update({ [`players/${mySlot}/bestWordUsed`]: true });
                        submitWord();
                    }, 300);
                }
            }, i * 120);
        });
    }, 150);
}

function findBestMoveVB(vBoard, rack, isFirst) {
    if (isFirst) return findFirstMoveVB(rack);

    let best = null, bestScore = 0;
    const anchors = [];
    for (let r=0;r<15;r++) for (let c=0;c<15;c++) {
        if (vBoard[r][c]) continue;
        if ([[0,1],[0,-1],[1,0],[-1,0]].some(([dr,dc]) => {
            const nr=r+dr,nc=c+dc;
            return nr>=0&&nr<15&&nc>=0&&nc<15&&vBoard[nr][nc];
        })) anchors.push([r,c]);
    }

    for (const [ar,ac] of anchors) {
        for (const dir of ['across','down']) {
            const moves = genMovesAt(vBoard, ar, ac, dir, rack);
            for (const m of moves) {
                // Verify connectivity: at least one placed tile must be adjacent to an existing board tile
                const connected = m.tiles.some(t =>
                    [[0,1],[0,-1],[1,0],[-1,0]].some(([dr,dc]) => {
                        const nr = t.row + dr, nc = t.col + dc;
                        if (nr < 0 || nr > 14 || nc < 0 || nc > 14) return false;
                        // Must be an existing board tile, NOT one of the tiles in this move
                        return vBoard[nr][nc] && !m.tiles.some(mt => mt.row === nr && mt.col === nc);
                    })
                );
                if (!connected) continue;

                // Verify all placed tiles are in a single line with no gaps
                if (m.tiles.length > 1) {
                    const rows = [...new Set(m.tiles.map(t => t.row))];
                    const cols = [...new Set(m.tiles.map(t => t.col))];
                    if (rows.length > 1 && cols.length > 1) continue; // not in a line

                    if (rows.length === 1) {
                        const r = rows[0];
                        const minC = Math.min(...m.tiles.map(t => t.col));
                        const maxC = Math.max(...m.tiles.map(t => t.col));
                        let hasGap = false;
                        for (let c = minC; c <= maxC; c++) {
                            if (!vBoard[r][c] && !m.tiles.some(t => t.row === r && t.col === c)) { hasGap = true; break; }
                        }
                        if (hasGap) continue;
                    } else {
                        const c = cols[0];
                        const minR = Math.min(...m.tiles.map(t => t.row));
                        const maxR = Math.max(...m.tiles.map(t => t.row));
                        let hasGap = false;
                        for (let r = minR; r <= maxR; r++) {
                            if (!vBoard[r][c] && !m.tiles.some(t => t.row === r && t.col === c)) { hasGap = true; break; }
                        }
                        if (hasGap) continue;
                    }
                }

                // Verify the word formed is in the dictionary
                if (m.word && m.word.length >= 2 && !DICT.has(m.word)) continue;

                if (m.score > bestScore) { bestScore = m.score; best = m; }
            }
        }
    }
    return best;
}

function findFirstMoveVB(rack) {
    let best = null, bestScore = 0;
    const words = wordsFromRack(rack);
    for (const w of words) {
        for (let sc = Math.max(0, 7-w.tiles.length+1); sc <= 7 && sc+w.tiles.length<=15; sc++) {
            if (sc+w.tiles.length-1 < 7) continue;
            const tiles = w.tiles.map((t,i) => ({ row:7, col:sc+i, displayLetter:t.d, rackLetter:t.r }));
            const score = scoreProspective(tiles, {});
            if (score > bestScore) { bestScore = score; best = { tiles, score, word: w.word }; }
        }
        for (let sr = Math.max(0, 7-w.tiles.length+1); sr <= 7 && sr+w.tiles.length<=15; sr++) {
            if (sr+w.tiles.length-1 < 7) continue;
            const tiles = w.tiles.map((t,i) => ({ row:sr+i, col:7, displayLetter:t.d, rackLetter:t.r }));
            const score = scoreProspective(tiles, {});
            if (score > bestScore) { bestScore = score; best = { tiles, score, word: w.word }; }
        }
    }
    return best;
}

function wordsFromRack(rack) {
    const results = [], counts = {};
    rack.forEach(l => counts[l]=(counts[l]||0)+1);
    function go(node, path, tiles, c) {
        if (node.w && path.length >= 2) results.push({ word: path, tiles: tiles.slice() });
        for (const ch in node.c) {
            if (c[ch] > 0) { c[ch]--; tiles.push({d:ch,r:ch}); go(node.c[ch], path+ch, tiles, c); tiles.pop(); c[ch]++; }
            if (c['_'] > 0) { c['_']--; tiles.push({d:ch,r:'_'}); go(node.c[ch], path+ch, tiles, c); tiles.pop(); c['_']++; }
        }
    }
    go(TRIE, '', [], {...counts});
    return results;
}

function genMovesAt(vBoard, ar, ac, dir, rack) {
    const moves = [], dr=dir==='down'?1:0, dc=dir==='across'?1:0;
    let prefLim = 0, pr=ar-dr, pc=ac-dc;
    while (pr>=0&&pc>=0&&!vBoard[pr][pc]) { prefLim++; pr-=dr; pc-=dc; if (prefLim>=rack.length) break; }
    let existPre = [], er=ar-dr, ec=ac-dc;
    while (er>=0&&ec>=0&&vBoard[er][ec]) { existPre.unshift(vBoard[er][ec]); er-=dr; ec-=dc; }
    const counts = {}; rack.forEach(l => counts[l]=(counts[l]||0)+1);

    if (existPre.length > 0) {
        let node = TRIE;
        for (const t of existPre) { if (!node.c[t.letter]) return moves; node = node.c[t.letter]; }
        extR(vBoard, node, ar, ac, [], existPre.map(t=>t.letter).join(''), {...counts}, moves, dir, dr, dc);
    } else {
        for (let len=0; len<=prefLim; len++) {
            if (len===0) extR(vBoard, TRIE, ar, ac, [], '', {...counts}, moves, dir, dr, dc);
            else bldPre(vBoard, TRIE, len, ar, ac, [], '', {...counts}, moves, dir, dr, dc);
        }
    }
    return moves;
}

function bldPre(vB, node, steps, aR, aC, placed, word, counts, moves, dir, dr, dc) {
    if (steps === 0) { extR(vB, node, aR, aC, placed.slice(), word, {...counts}, moves, dir, dr, dc); return; }
    const r=aR-dr*steps, c=aC-dc*steps;
    if (r<0||r>14||c<0||c>14||vB[r][c]) return; // out of bounds or occupied
    for (const ch in node.c) {
        if (!chkCross(vB, r, c, ch, dir)) continue;
        if (counts[ch]>0) { counts[ch]--; placed.push({row:r,col:c,displayLetter:ch,rackLetter:ch}); bldPre(vB,node.c[ch],steps-1,aR,aC,placed,word+ch,counts,moves,dir,dr,dc); placed.pop(); counts[ch]++; }
        if (counts['_']>0) { counts['_']--; placed.push({row:r,col:c,displayLetter:ch,rackLetter:'_'}); bldPre(vB,node.c[ch],steps-1,aR,aC,placed,word+ch,counts,moves,dir,dr,dc); placed.pop(); counts['_']++; }
    }
}

function extR(vB, node, r, c, placed, word, counts, moves, dir, dr, dc) {
    if (r<0||r>14||c<0||c>14) {
        if (node.w && word.length>=2 && placed.length>0) {
            const boardMap = gameData?.board || {};
            moves.push({ tiles:placed.slice(), score:scoreProspective(placed, boardMap), word });
        }
        return;
    }
    const ex = vB[r][c];
    if (ex) {
        if (node.c[ex.letter]) extR(vB, node.c[ex.letter], r+dr, c+dc, placed, word+ex.letter, counts, moves, dir, dr, dc);
    } else {
        if (node.w && word.length>=2 && placed.length>0) {
            const boardMap = gameData?.board || {};
            moves.push({ tiles:placed.slice(), score:scoreProspective(placed, boardMap), word });
        }
        for (const ch in node.c) {
            if (!chkCross(vB, r, c, ch, dir)) continue;
            if (counts[ch]>0) { counts[ch]--; placed.push({row:r,col:c,displayLetter:ch,rackLetter:ch}); extR(vB,node.c[ch],r+dr,c+dc,placed,word+ch,counts,moves,dir,dr,dc); placed.pop(); counts[ch]++; }
            if (counts['_']>0) { counts['_']--; placed.push({row:r,col:c,displayLetter:ch,rackLetter:'_'}); extR(vB,node.c[ch],r+dr,c+dc,placed,word+ch,counts,moves,dir,dr,dc); placed.pop(); counts['_']++; }
        }
    }
}

function chkCross(vB, row, col, letter, mainDir) {
    const dr=mainDir==='across'?1:0, dc=mainDir==='down'?1:0;
    let r=row-dr, c=col-dc, before='';
    while (r>=0&&c>=0&&vB[r][c]) { before=vB[r][c].letter+before; r-=dr; c-=dc; }
    r=row+dr; c=col+dc; let after='';
    while (r<15&&c<15&&vB[r][c]) { after+=vB[r][c].letter; r+=dr; c+=dc; }
    if (!before && !after) return true;
    return DICT.has(before+letter+after);
}

function scoreProspective(tiles, boardMap) {
    const newPos = new Set(tiles.map(t=>`${t.row},${t.col}`));
    const tileMap = {}; tiles.forEach(t => tileMap[`${t.row},${t.col}`]=t);
    let total = 0;

    function getW(row,col,dir) {
        const dr=dir==='down'?1:0,dc=dir==='across'?1:0;
        const cells=[]; let r=row,c=col;
        while (r-dr>=0&&c-dc>=0&&(boardMap[`${r-dr},${c-dc}`]||tileMap[`${r-dr},${c-dc}`])) { r-=dr; c-=dc; }
        while (r>=0&&r<15&&c>=0&&c<15) {
            const k=`${r},${c}`;
            if (boardMap[k]) cells.push({row:r,col:c,letter:boardMap[k].letter,isBlank:boardMap[k].isBlank||false});
            else if (tileMap[k]) cells.push({row:r,col:c,letter:tileMap[k].displayLetter,isBlank:tileMap[k].rackLetter==='_'});
            else break;
            r+=dr; c+=dc;
        }
        return cells;
    }

    function scoreW(cells) {
        let ws=0,wm=1;
        for (const c of cells) {
            const lv=c.isBlank?0:(LETTER_VALUES[c.letter]||0); let ls=lv;
            if (newPos.has(`${c.row},${c.col}`)) {
                const pr=PREMIUM[`${c.row},${c.col}`];
                if (pr==='dl') ls*=2; if (pr==='tl') ls*=3;
                if (pr==='dw') wm*=2; if (pr==='tw') wm*=3;
            }
            ws+=ls;
        }
        return ws*wm;
    }

    if (tiles.length===1) {
        const h=getW(tiles[0].row,tiles[0].col,'across'); if (h.length>=2) total+=scoreW(h);
        const v=getW(tiles[0].row,tiles[0].col,'down'); if (v.length>=2) total+=scoreW(v);
    } else {
        const rows=new Set(tiles.map(t=>t.row));
        const mainDir=rows.size===1?'across':'down';
        const main=getW(tiles[0].row,tiles[0].col,mainDir); if (main.length>=2) total+=scoreW(main);
        const crossDir=mainDir==='across'?'down':'across';
        for (const t of tiles) { const cw=getW(t.row,t.col,crossDir); if (cw.length>=2) total+=scoreW(cw); }
    }
    if (tiles.length===7) total+=50;
    return total;
}

// ==================== GAME OVER ====================

function showGameOver(data) {
    clearInterval(timerInterval);
    const p = data.players;
    // Final scoring adjustments
    let s0 = p[0].score, s1 = p[1].score;
    const r0 = (data.racks?.[0] || []).reduce((s,l) => s + (l==='_'?0:(LETTER_VALUES[l]||0)), 0);
    const r1 = (data.racks?.[1] || []).reduce((s,l) => s + (l==='_'?0:(LETTER_VALUES[l]||0)), 0);
    s0 -= r0; s1 -= r1;
    if ((data.racks?.[0]||[]).length === 0) s0 += r1;
    if ((data.racks?.[1]||[]).length === 0) s1 += r0;
    if (s0 < 0) s0 = 0; if (s1 < 0) s1 = 0;

    const winner = s0 > s1 ? p[0].name : s1 > s0 ? p[1].name : null;
    document.getElementById('winnerText').textContent = winner ? `${winner} wins!` : "It's a tie!";
    document.getElementById('finalScores').innerHTML = [
        { name: p[0].name, score: s0 },
        { name: p[1].name, score: s1 }
    ].map(x => `<div class="fs-card"><div class="fs-name">${esc(x.name)}</div><div class="fs-score">${x.score}</div></div>`).join('');
    document.getElementById('gameOverModal').classList.add('active');
}

// ==================== THEME ====================

function initTheme() {
    const toggle = document.getElementById('themeToggle');
    const html = document.documentElement;
    function set(t) { html.setAttribute('data-theme',t); localStorage.setItem('theme',t); toggle.textContent=t==='dark'?'\u{1F319}':'\u2600\uFE0F'; }
    const saved = localStorage.getItem('theme');
    if (saved) set(saved);
    else if (window.matchMedia?.('(prefers-color-scheme: light)').matches) set('light');
    toggle.addEventListener('click', () => set(html.getAttribute('data-theme')==='dark'?'light':'dark'));
}

// ==================== INIT ====================

document.addEventListener('DOMContentLoaded', () => {
    initTheme();
    initLobby();
    initActions();
    initTaunt();
    loadDict();
});
</script>
</body>
</html>
