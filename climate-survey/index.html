<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climate Warming Trajectory Survey</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.0"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
        }

        header {
            text-align: center;
            padding: 2.5rem 1.5rem 1rem;
            max-width: 800px;
            margin: 0 auto;
        }

        header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #fff;
            letter-spacing: -0.02em;
        }

        header p {
            margin-top: 0.6rem;
            font-size: 0.95rem;
            color: #888;
            line-height: 1.5;
        }

        .section {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 1.5rem;
        }

        .chart-panel {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 1.25rem;
            margin-top: 1.5rem;
        }

        .chart-panel h2 {
            font-size: 1rem;
            font-weight: 600;
            color: #ccc;
            margin-bottom: 0.75rem;
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 420px;
        }

        .chart-container canvas {
            touch-action: none;
        }

        .instructions-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding: 0.6rem 0.75rem;
            background: rgba(0, 212, 255, 0.06);
            border: 1px solid rgba(0, 212, 255, 0.15);
            border-radius: 8px;
            font-size: 0.82rem;
            color: #8ecfdf;
        }

        .instructions-bar .icon {
            font-size: 1.1rem;
            flex-shrink: 0;
        }

        .controls {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.6rem 1.25rem;
            border: 1px solid #333;
            border-radius: 8px;
            background: #222;
            color: #ccc;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        button:hover:not(:disabled) {
            background: #2a2a2a;
            border-color: #555;
            color: #fff;
        }

        button:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        button.primary {
            background: #00a8cc;
            border-color: #00a8cc;
            color: #fff;
        }

        button.primary:hover:not(:disabled) {
            background: #00bde0;
            border-color: #00bde0;
        }

        button.danger {
            border-color: #552222;
            color: #cc6666;
        }

        button.danger:hover:not(:disabled) {
            background: #2a1515;
            border-color: #883333;
        }

        #results-section {
            display: none;
            margin-top: 2rem;
            padding-bottom: 2rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .stat-card {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 0.85rem;
            text-align: center;
        }

        .stat-card .value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #00d4ff;
        }

        .stat-card .label {
            font-size: 0.75rem;
            color: #777;
            margin-top: 0.25rem;
        }

        .results-controls {
            margin-top: 1rem;
            display: flex;
            gap: 0.75rem;
        }

        footer {
            text-align: center;
            padding: 2rem 1.5rem 3rem;
            font-size: 0.78rem;
            color: #555;
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.6;
        }

        footer a {
            color: #777;
            text-decoration: none;
        }

        footer a:hover {
            color: #aaa;
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            header { padding: 1.5rem 1rem 0.5rem; }
            header h1 { font-size: 1.4rem; }
            .section { padding: 0 1rem; }
            .chart-container { height: 320px; }
            .controls { gap: 0.5rem; }
            button { padding: 0.5rem 0.9rem; font-size: 0.8rem; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Climate Warming Trajectory Survey</h1>
        <p>How warm do you think the planet will get? Draw your prediction for global temperature anomaly from 2026 to 2100, based on historical observations.</p>
    </header>

    <div class="section">
        <div class="chart-panel">
            <h2>Global Temperature Anomaly (relative to 1850&ndash;1900 baseline)</h2>
            <div class="chart-container">
                <canvas id="mainChart"></canvas>
            </div>
            <div class="instructions-bar">
                <span class="icon">&#9998;</span>
                <span>Click and drag in the shaded area (2026&ndash;2100) to draw your predicted temperature trajectory. Your line can go up, down, or both.</span>
            </div>
            <div class="controls">
                <button id="clearBtn" disabled>Clear Drawing</button>
                <button id="smoothBtn" disabled>Smooth Curve</button>
                <button id="submitBtn" class="primary" disabled>Submit Prediction</button>
            </div>
        </div>
    </div>

    <div class="section" id="results-section">
        <div class="chart-panel">
            <h2>Community Predictions</h2>
            <div class="chart-container">
                <canvas id="resultsChart"></canvas>
            </div>
        </div>
        <div class="stats-grid" id="statsGrid"></div>
        <div class="results-controls">
            <button id="clearDataBtn" class="danger">Clear All My Data</button>
        </div>
    </div>

    <footer>
        Historical data: ERA5, Berkeley Earth, GISTEMP, HadCRUT5, JRA-3Q, NOAAGlobalTemp v6.<br>
        Anomalies relative to the 1850&ndash;1900 pre-industrial baseline.<br>
        <a href="/">&#8592; Back to Home</a>
    </footer>

    <script>
    (function() {
        'use strict';

        // =====================================================================
        // 1. HISTORICAL DATA (from ERA5 + multi-dataset CSV)
        // =====================================================================
        // ERA5 column (1940-2024), null before 1940
        // Multi-dataset mean: average of all non-null values per year
        const RAW = [
            [1850,null,-0.0364],[1851,null,0.0673],[1852,null,0.0897],[1853,null,0.0561],[1854,null,0.0603],
            [1855,null,0.0549],[1856,null,-0.0193],[1857,null,-0.1295],[1858,null,-0.0312],[1859,null,0.0863],
            [1860,null,-0.0611],[1861,null,-0.1185],[1862,null,-0.2127],[1863,null,-0.0222],[1864,null,-0.0725],
            [1865,null,0.0420],[1866,null,0.0474],[1867,null,0.0271],[1868,null,0.0338],[1869,null,0.0685],
            [1870,null,0.0089],[1871,null,-0.0131],[1872,null,-0.0003],[1873,null,0.0056],[1874,null,-0.0318],
            [1875,null,-0.0422],[1876,null,-0.0680],[1877,null,0.2864],[1878,null,0.3474],[1879,null,0.0477],
            [1880,0.0962,0.0305],[1881,0.1796,0.1226],[1882,0.1613,0.0694],[1883,0.0946,0.0194],
            [1884,-0.0146,-0.1140],[1885,-0.0629,-0.0839],[1886,-0.0471,-0.0987],[1887,-0.0971,-0.1519],
            [1888,0.0962,0.0363],[1889,0.1613,0.1303],[1890,-0.0854,-0.1451],[1891,0.0454,-0.0230],
            [1892,-0.0054,-0.0864],[1893,-0.0446,-0.1047],[1894,-0.0379,-0.0974],[1895,0.0396,-0.0394],
            [1896,0.1554,0.0957],[1897,0.1587,0.0978],[1898,-0.0054,-0.0789],[1899,0.0921,0.0445],
            [1900,0.1846,0.1498],[1901,0.1162,0.0864],[1902,-0.0112,-0.0498],[1903,-0.1004,-0.1552],
            [1904,-0.1979,-0.2273],[1905,0.0087,-0.0371],[1906,0.0537,0.0375],[1907,-0.1129,-0.1389],
            [1908,-0.1546,-0.1764],[1909,-0.2138,-0.2143],[1910,-0.1663,-0.1784],[1911,-0.1688,-0.1915],
            [1912,-0.0896,-0.1199],[1913,-0.0738,-0.1040],[1914,0.1171,0.0856],[1915,0.1279,0.1330],
            [1916,-0.0888,-0.0913],[1917,-0.1871,-0.2165],[1918,-0.0263,-0.0744],[1919,-0.0071,-0.0103],
            [1920,-0.0038,0.0110],[1921,0.0837,0.0766],[1922,-0.0129,-0.0110],[1923,0.0062,0.0042],
            [1924,0.0012,0.0069],[1925,0.0487,0.0434],[1926,0.1637,0.1797],[1927,0.0554,0.0727],
            [1928,0.0687,0.0873],[1929,-0.0888,-0.0848],[1930,0.1179,0.1295],[1931,0.1812,0.1940],
            [1932,0.1137,0.1377],[1933,-0.0112,-0.0153],[1934,0.1479,0.1332],[1935,0.0762,0.0799],
            [1936,0.1271,0.1295],[1937,0.2437,0.2614],[1938,0.2721,0.2747],[1939,0.2529,0.2600],
            [1940,0.1954,0.3238],[1941,0.2429,0.3624],[1942,0.1512,0.2678],[1943,0.1562,0.2821],
            [1944,0.3479,0.4451],[1945,0.2087,0.3316],[1946,0.2121,0.2002],[1947,0.2562,0.2143],
            [1948,0.1954,0.1824],[1949,0.2279,0.1820],[1950,0.1162,0.1005],[1951,0.2479,0.2425],
            [1952,0.2337,0.2888],[1953,0.3104,0.3644],[1954,0.1137,0.1681],[1955,0.0937,0.1253],
            [1956,0.0354,0.0690],[1957,0.2837,0.3044],[1958,0.3496,0.3341],[1959,0.3154,0.3017],
            [1960,0.2696,0.2477],[1961,0.3454,0.3172],[1962,0.2854,0.2848],[1963,0.3221,0.3079],
            [1964,0.1112,0.0566],[1965,0.1737,0.1624],[1966,0.2496,0.2161],[1967,0.2629,0.2448],
            [1968,0.2029,0.1897],[1969,0.3321,0.3242],[1970,0.3062,0.2847],[1971,0.1537,0.1647],
            [1972,0.2871,0.2772],[1973,0.3912,0.4114],[1974,0.1171,0.1843],[1975,0.1404,0.2200],
            [1976,0.0712,0.1473],[1977,0.3562,0.4225],[1978,0.2987,0.3317],[1979,0.4537,0.4347],
            [1980,0.5854,0.5407],[1981,0.6196,0.5907],[1982,0.4196,0.3963],[1983,0.6146,0.5804],
            [1984,0.4012,0.4059],[1985,0.3612,0.3790],[1986,0.4496,0.4548],[1987,0.6062,0.5958],
            [1988,0.6371,0.6374],[1989,0.5179,0.5242],[1990,0.7496,0.7159],[1991,0.6954,0.6786],
            [1992,0.4637,0.4730],[1993,0.5096,0.5114],[1994,0.5462,0.5718],[1995,0.7229,0.7270],
            [1996,0.5921,0.6119],[1997,0.7162,0.7438],[1998,0.9029,0.9049],[1999,0.6362,0.6599],
            [2000,0.6304,0.6636],[2001,0.7904,0.8086],[2002,0.8879,0.8874],[2003,0.8737,0.8808],
            [2004,0.8137,0.8049],[2005,0.9762,0.9576],[2006,0.9279,0.9104],[2007,0.9196,0.9148],
            [2008,0.7871,0.7930],[2009,0.9179,0.9199],[2010,1.0137,0.9998],[2011,0.8712,0.8770],
            [2012,0.9221,0.9124],[2013,0.9504,0.9472],[2014,0.9896,1.0046],[2015,1.1396,1.1547],
            [2016,1.3237,1.2941],[2017,1.2271,1.1961],[2018,1.1462,1.1183],[2019,1.2837,1.2478],
            [2020,1.3162,1.2814],[2021,1.1562,1.1145],[2022,1.1846,1.1564],[2023,1.4837,1.4528],
            [2024,1.6027,1.5523]
        ];

        const HIST_YEARS = [], ERA5 = [], MULTI_MEAN = [];
        for (const row of RAW) {
            HIST_YEARS.push(row[0]);
            ERA5.push(row[1]);
            MULTI_MEAN.push(row[2]);
        }

        const LAST_HIST_YEAR = 2024;
        const LAST_ERA5_TEMP = 1.6027;
        const PREDICT_START = 2026;
        const PREDICT_END = 2100;

        // =====================================================================
        // 2. CHART SETUP
        // =====================================================================
        const mainCtx = document.getElementById('mainChart').getContext('2d');

        // Build historical datasets
        const era5Data = [], multiData = [];
        for (let i = 0; i < HIST_YEARS.length; i++) {
            if (ERA5[i] !== null) era5Data.push({ x: HIST_YEARS[i], y: ERA5[i] });
            multiData.push({ x: HIST_YEARS[i], y: MULTI_MEAN[i] });
        }

        // Prediction zone plugin
        const predictionZonePlugin = {
            id: 'predictionZone',
            beforeDatasetsDraw(chart) {
                const ctx = chart.ctx;
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;
                const left = xScale.getPixelForValue(PREDICT_START);
                const right = xScale.getPixelForValue(PREDICT_END);
                const top = chart.chartArea.top;
                const bottom = chart.chartArea.bottom;
                ctx.save();
                ctx.fillStyle = 'rgba(255,255,255,0.03)';
                ctx.fillRect(left, top, right - left, bottom - top);

                // Dashed vertical line at prediction start
                ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(left, top);
                ctx.lineTo(left, bottom);
                ctx.stroke();
                ctx.restore();
            }
        };

        let drawnPoints = [];
        let smoothedPoints = [];
        let isDrawing = false;

        const mainChart = new Chart(mainCtx, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: 'Multi-dataset Mean',
                        data: multiData,
                        borderColor: 'rgba(150,150,150,0.35)',
                        borderWidth: 1.2,
                        pointRadius: 0,
                        pointHitRadius: 0,
                        tension: 0.3,
                        order: 3
                    },
                    {
                        label: 'ERA5',
                        data: era5Data,
                        borderColor: '#ff6b35',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHitRadius: 0,
                        tension: 0.1,
                        order: 2
                    },
                    {
                        label: 'Your Prediction',
                        data: [],
                        borderColor: '#00d4ff',
                        borderWidth: 2.5,
                        pointRadius: 0,
                        pointHitRadius: 0,
                        tension: 0,
                        order: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: { mode: 'nearest', intersect: false },
                scales: {
                    x: {
                        type: 'linear',
                        min: 1850,
                        max: 2100,
                        ticks: {
                            stepSize: 25,
                            color: '#666',
                            font: { size: 11 }
                        },
                        grid: { color: 'rgba(255,255,255,0.05)' },
                        title: { display: true, text: 'Year', color: '#777', font: { size: 12 } }
                    },
                    y: {
                        min: -0.5,
                        max: 5.0,
                        ticks: {
                            stepSize: 0.5,
                            color: '#666',
                            font: { size: 11 },
                            callback: v => v.toFixed(1) + '\u00B0C'
                        },
                        grid: { color: 'rgba(255,255,255,0.05)' },
                        title: { display: true, text: 'Temperature Anomaly (\u00B0C)', color: '#777', font: { size: 12 } }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#999',
                            font: { size: 11 },
                            usePointStyle: true,
                            pointStyle: 'line',
                            padding: 16
                        }
                    },
                    annotation: {
                        annotations: {
                            line15: {
                                type: 'line',
                                yMin: 1.5,
                                yMax: 1.5,
                                borderColor: 'rgba(251, 191, 36, 0.5)',
                                borderWidth: 1.5,
                                borderDash: [6, 4],
                                label: {
                                    display: true,
                                    content: '1.5\u00B0C',
                                    position: 'start',
                                    backgroundColor: 'rgba(251,191,36,0.15)',
                                    color: '#fbbf24',
                                    font: { size: 10 },
                                    padding: 3
                                }
                            },
                            line20: {
                                type: 'line',
                                yMin: 2.0,
                                yMax: 2.0,
                                borderColor: 'rgba(239, 68, 68, 0.5)',
                                borderWidth: 1.5,
                                borderDash: [6, 4],
                                label: {
                                    display: true,
                                    content: '2.0\u00B0C',
                                    position: 'start',
                                    backgroundColor: 'rgba(239,68,68,0.15)',
                                    color: '#ef4444',
                                    font: { size: 10 },
                                    padding: 3
                                }
                            }
                        }
                    },
                    tooltip: { enabled: false }
                }
            },
            plugins: [predictionZonePlugin]
        });

        // =====================================================================
        // 3. DRAWING INTERACTION
        // =====================================================================
        const canvas = mainChart.canvas;
        const clearBtn = document.getElementById('clearBtn');
        const smoothBtn = document.getElementById('smoothBtn');
        const submitBtn = document.getElementById('submitBtn');

        function getCanvasPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function pixelToData(px, py) {
            const xScale = mainChart.scales.x;
            const yScale = mainChart.scales.y;
            return {
                year: xScale.getValueForPixel(px),
                temp: yScale.getValueForPixel(py)
            };
        }

        function isInPredictZone(px) {
            const xScale = mainChart.scales.x;
            const leftPx = xScale.getPixelForValue(PREDICT_START);
            const rightPx = xScale.getPixelForValue(PREDICT_END);
            return px >= leftPx - 5 && px <= rightPx + 5;
        }

        function clampData(year, temp) {
            return {
                year: Math.max(PREDICT_START, Math.min(PREDICT_END, year)),
                temp: Math.max(-0.5, Math.min(5.0, temp))
            };
        }

        function updatePredictionDataset(pts) {
            // Prepend anchor point to connect to historical data
            const anchor = { x: LAST_HIST_YEAR, y: LAST_ERA5_TEMP };
            const data = [anchor, ...pts.map(p => ({ x: p.year, y: p.temp }))];
            mainChart.data.datasets[2].data = data;
            mainChart.update('none');
        }

        function updateButtons() {
            const hasDrawn = drawnPoints.length > 5;
            clearBtn.disabled = !hasDrawn;
            smoothBtn.disabled = !hasDrawn;

            // Check coverage: need to span most of the range
            if (hasDrawn) {
                const maxYear = Math.max(...drawnPoints.map(p => p.year));
                submitBtn.disabled = maxYear < 2090;
            } else {
                submitBtn.disabled = true;
            }
        }

        function onDrawStart(e) {
            const pos = getCanvasPos(e);
            if (!isInPredictZone(pos.x)) return;
            if (e.cancelable) e.preventDefault();
            isDrawing = true;
            drawnPoints = [];
            smoothedPoints = [];
            const d = clampData(...Object.values(pixelToData(pos.x, pos.y)));
            drawnPoints.push(d);
            updatePredictionDataset(drawnPoints);
        }

        function onDrawMove(e) {
            if (!isDrawing) return;
            if (e.cancelable) e.preventDefault();
            const pos = getCanvasPos(e);
            const d = clampData(...Object.values(pixelToData(pos.x, pos.y)));
            drawnPoints.push(d);
            updatePredictionDataset(drawnPoints);
            updateButtons();
        }

        function onDrawEnd(e) {
            if (!isDrawing) return;
            isDrawing = false;
            updateButtons();
        }

        canvas.addEventListener('mousedown', onDrawStart);
        canvas.addEventListener('mousemove', onDrawMove);
        canvas.addEventListener('mouseup', onDrawEnd);
        canvas.addEventListener('mouseleave', onDrawEnd);
        canvas.addEventListener('touchstart', onDrawStart, { passive: false });
        canvas.addEventListener('touchmove', onDrawMove, { passive: false });
        canvas.addEventListener('touchend', onDrawEnd);
        canvas.addEventListener('touchcancel', onDrawEnd);

        // =====================================================================
        // 4. CUBIC SPLINE SMOOTHING
        // =====================================================================
        function downsampleByYear(points, numBuckets) {
            if (points.length === 0) return [];
            const minYear = PREDICT_START;
            const maxYear = PREDICT_END;
            const bucketWidth = (maxYear - minYear) / numBuckets;
            const buckets = [];
            for (let i = 0; i < numBuckets; i++) {
                buckets.push([]);
            }
            for (const p of points) {
                const idx = Math.min(numBuckets - 1, Math.floor((p.year - minYear) / bucketWidth));
                if (idx >= 0 && idx < numBuckets) buckets[idx].push(p.temp);
            }

            const controlPoints = [];
            for (let i = 0; i < numBuckets; i++) {
                if (buckets[i].length > 0) {
                    const sorted = buckets[i].slice().sort((a, b) => a - b);
                    const median = sorted[Math.floor(sorted.length / 2)];
                    const yearCenter = minYear + (i + 0.5) * bucketWidth;
                    controlPoints.push({ year: yearCenter, temp: median });
                }
            }
            return controlPoints;
        }

        function naturalCubicSpline(pts) {
            // pts = [{year, temp}, ...] sorted by year, at least 2 points
            const n = pts.length - 1;
            if (n < 1) return pts;

            const x = pts.map(p => p.year);
            const y = pts.map(p => p.temp);
            const h = [];
            for (let i = 0; i < n; i++) h.push(x[i + 1] - x[i]);

            if (n === 1) {
                // Linear interpolation for 2 points
                return function(t) {
                    const frac = (t - x[0]) / (x[1] - x[0]);
                    return y[0] + frac * (y[1] - y[0]);
                };
            }

            // Solve tridiagonal system for second derivatives M
            const alpha = [];
            for (let i = 1; i < n; i++) {
                alpha.push(3 / h[i] * (y[i + 1] - y[i]) - 3 / h[i - 1] * (y[i] - y[i - 1]));
            }

            const l = new Array(n + 1).fill(1);
            const mu = new Array(n + 1).fill(0);
            const z = new Array(n + 1).fill(0);

            for (let i = 1; i < n; i++) {
                l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
                mu[i] = h[i] / l[i];
                z[i] = (alpha[i - 1] - h[i - 1] * z[i - 1]) / l[i];
            }

            const c = new Array(n + 1).fill(0);
            const b = new Array(n).fill(0);
            const d = new Array(n).fill(0);

            for (let j = n - 1; j >= 0; j--) {
                c[j] = z[j] - mu[j] * c[j + 1];
                b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
                d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
            }

            return function(t) {
                // Find interval
                let i = 0;
                for (i = 0; i < n - 1; i++) {
                    if (t < x[i + 1]) break;
                }
                const dx = t - x[i];
                return y[i] + b[i] * dx + c[i] * dx * dx + d[i] * dx * dx * dx;
            };
        }

        function smoothDrawing() {
            if (drawnPoints.length < 3) return;

            // Downsample to control points
            let cps = downsampleByYear(drawnPoints, 30);
            if (cps.length < 2) return;

            // Sort by year
            cps.sort((a, b) => a.year - b.year);

            // Ensure we start at PREDICT_START anchored to last historical temp
            if (cps[0].year > PREDICT_START + 1) {
                cps.unshift({ year: PREDICT_START, temp: LAST_ERA5_TEMP });
            }

            // Build spline
            const splineFn = naturalCubicSpline(cps);
            if (typeof splineFn !== 'function') return;

            // Evaluate at integer years
            smoothedPoints = [];
            for (let yr = PREDICT_START; yr <= PREDICT_END; yr++) {
                let temp = splineFn(yr);
                temp = Math.max(-0.5, Math.min(5.0, temp));
                smoothedPoints.push({ year: yr, temp: Math.round(temp * 100) / 100 });
            }

            updatePredictionDataset(smoothedPoints);
            // Update drawn points to be the smoothed ones for submission
            drawnPoints = smoothedPoints.slice();
            updateButtons();
        }

        // =====================================================================
        // 5. LOCALSTORAGE PERSISTENCE
        // =====================================================================
        const STORAGE_KEY = 'climate-survey-submissions';

        function loadSubmissions() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                return raw ? JSON.parse(raw) : [];
            } catch { return []; }
        }

        function saveSubmission(points) {
            const submissions = loadSubmissions();
            submissions.push({
                id: Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
                timestamp: new Date().toISOString(),
                points: points
            });
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(submissions));
            } catch (e) {
                alert('Could not save — storage may be full.');
            }
            return submissions;
        }

        function clearAllSubmissions() {
            localStorage.removeItem(STORAGE_KEY);
        }

        // =====================================================================
        // 6. RESULTS VISUALIZATION
        // =====================================================================
        let resultsChart = null;

        function renderResults(submissions, latestPoints) {
            const section = document.getElementById('results-section');
            if (submissions.length === 0) {
                section.style.display = 'none';
                return;
            }
            section.style.display = 'block';

            // Compute envelope and mean
            const envelopeMin = [], envelopeMax = [], meanLine = [];
            for (let yr = PREDICT_START; yr <= PREDICT_END; yr++) {
                const temps = [];
                for (const sub of submissions) {
                    const pt = sub.points.find(p => p.year === yr);
                    if (pt) temps.push(pt.temp);
                }
                if (temps.length > 0) {
                    envelopeMin.push({ x: yr, y: Math.min(...temps) });
                    envelopeMax.push({ x: yr, y: Math.max(...temps) });
                    meanLine.push({ x: yr, y: temps.reduce((a, b) => a + b, 0) / temps.length });
                }
            }

            // Latest submission data
            const latestData = latestPoints
                ? [{ x: LAST_HIST_YEAR, y: LAST_ERA5_TEMP }, ...latestPoints.map(p => ({ x: p.year, y: p.temp }))]
                : [];

            const datasets = [
                {
                    label: 'Multi-dataset Mean',
                    data: multiData,
                    borderColor: 'rgba(150,150,150,0.3)',
                    borderWidth: 1,
                    pointRadius: 0,
                    tension: 0.3,
                    order: 5
                },
                {
                    label: 'ERA5',
                    data: era5Data,
                    borderColor: '#ff6b35',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    order: 4
                },
                {
                    label: 'Prediction Range (max)',
                    data: envelopeMax,
                    borderColor: 'transparent',
                    backgroundColor: 'rgba(0, 212, 255, 0.12)',
                    borderWidth: 0,
                    pointRadius: 0,
                    fill: '+1',
                    order: 3
                },
                {
                    label: 'Prediction Range (min)',
                    data: envelopeMin,
                    borderColor: 'transparent',
                    borderWidth: 0,
                    pointRadius: 0,
                    fill: false,
                    order: 3
                },
                {
                    label: 'Community Mean',
                    data: meanLine,
                    borderColor: 'rgba(0, 212, 255, 0.6)',
                    borderWidth: 2,
                    borderDash: [4, 3],
                    pointRadius: 0,
                    tension: 0.2,
                    order: 2
                }
            ];

            if (latestData.length > 0) {
                datasets.push({
                    label: 'Your Latest',
                    data: latestData,
                    borderColor: '#00d4ff',
                    borderWidth: 2.5,
                    pointRadius: 0,
                    tension: 0.1,
                    order: 1
                });
            }

            if (resultsChart) resultsChart.destroy();
            const rCtx = document.getElementById('resultsChart').getContext('2d');
            resultsChart = new Chart(rCtx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 400 },
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: {
                            type: 'linear',
                            min: 1850,
                            max: 2100,
                            ticks: { stepSize: 25, color: '#666', font: { size: 11 } },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            title: { display: true, text: 'Year', color: '#777', font: { size: 12 } }
                        },
                        y: {
                            min: -0.5,
                            max: 5.0,
                            ticks: {
                                stepSize: 0.5,
                                color: '#666',
                                font: { size: 11 },
                                callback: v => v.toFixed(1) + '\u00B0C'
                            },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            title: { display: true, text: 'Temperature Anomaly (\u00B0C)', color: '#777', font: { size: 12 } }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#999',
                                font: { size: 11 },
                                usePointStyle: true,
                                pointStyle: 'line',
                                padding: 16,
                                filter: item => !item.text.includes('(min)')
                            }
                        },
                        annotation: {
                            annotations: {
                                line15: {
                                    type: 'line', yMin: 1.5, yMax: 1.5,
                                    borderColor: 'rgba(251,191,36,0.5)', borderWidth: 1.5, borderDash: [6, 4],
                                    label: { display: true, content: '1.5\u00B0C', position: 'start', backgroundColor: 'rgba(251,191,36,0.15)', color: '#fbbf24', font: { size: 10 }, padding: 3 }
                                },
                                line20: {
                                    type: 'line', yMin: 2.0, yMax: 2.0,
                                    borderColor: 'rgba(239,68,68,0.5)', borderWidth: 1.5, borderDash: [6, 4],
                                    label: { display: true, content: '2.0\u00B0C', position: 'start', backgroundColor: 'rgba(239,68,68,0.15)', color: '#ef4444', font: { size: 10 }, padding: 3 }
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: item => item.dataset.label + ': ' + item.parsed.y.toFixed(2) + '\u00B0C'
                            }
                        }
                    }
                },
                plugins: [predictionZonePlugin]
            });

            // Stats
            renderStats(submissions, meanLine);
        }

        function renderStats(submissions, meanLine) {
            const grid = document.getElementById('statsGrid');

            const count = submissions.length;
            const lastMean = meanLine.length > 0 ? meanLine[meanLine.length - 1].y : null;

            // Find crossing years from mean
            let cross15 = null, cross20 = null;
            for (const pt of meanLine) {
                if (cross15 === null && pt.y >= 1.5) cross15 = Math.round(pt.x);
                if (cross20 === null && pt.y >= 2.0) cross20 = Math.round(pt.x);
            }

            grid.innerHTML = `
                <div class="stat-card">
                    <div class="value">${count}</div>
                    <div class="label">Total Predictions</div>
                </div>
                <div class="stat-card">
                    <div class="value">${lastMean !== null ? lastMean.toFixed(2) + '\u00B0C' : '—'}</div>
                    <div class="label">Mean at 2100</div>
                </div>
                <div class="stat-card">
                    <div class="value">${cross15 ? cross15 : 'Never'}</div>
                    <div class="label">Mean Crosses 1.5\u00B0C</div>
                </div>
                <div class="stat-card">
                    <div class="value">${cross20 ? cross20 : 'Never'}</div>
                    <div class="label">Mean Crosses 2.0\u00B0C</div>
                </div>
            `;
        }

        // =====================================================================
        // 7. BUTTON HANDLERS
        // =====================================================================
        clearBtn.addEventListener('click', () => {
            drawnPoints = [];
            smoothedPoints = [];
            mainChart.data.datasets[2].data = [];
            mainChart.update('none');
            updateButtons();
        });

        smoothBtn.addEventListener('click', () => {
            smoothDrawing();
        });

        submitBtn.addEventListener('click', () => {
            // Auto-smooth if not already
            if (smoothedPoints.length === 0) {
                smoothDrawing();
            }

            const pts = smoothedPoints.length > 0 ? smoothedPoints : drawnPoints;
            if (pts.length === 0) return;

            // Normalize to integer years
            const normalized = [];
            const yearMap = {};
            for (const p of pts) {
                const yr = Math.round(p.year);
                if (yr >= PREDICT_START && yr <= PREDICT_END) {
                    yearMap[yr] = p.temp;
                }
            }

            // Fill in any gaps with linear interpolation
            const filledYears = Object.keys(yearMap).map(Number).sort((a, b) => a - b);
            if (filledYears.length < 2) return;

            for (let yr = PREDICT_START; yr <= PREDICT_END; yr++) {
                if (yearMap[yr] !== undefined) {
                    normalized.push({ year: yr, temp: Math.round(yearMap[yr] * 100) / 100 });
                } else {
                    // Find bracketing known years
                    let lo = null, hi = null;
                    for (const fy of filledYears) {
                        if (fy <= yr) lo = fy;
                        if (fy >= yr && hi === null) hi = fy;
                    }
                    if (lo !== null && hi !== null && lo !== hi) {
                        const frac = (yr - lo) / (hi - lo);
                        const t = yearMap[lo] + frac * (yearMap[hi] - yearMap[lo]);
                        normalized.push({ year: yr, temp: Math.round(t * 100) / 100 });
                    } else if (lo !== null) {
                        normalized.push({ year: yr, temp: Math.round(yearMap[lo] * 100) / 100 });
                    } else if (hi !== null) {
                        normalized.push({ year: yr, temp: Math.round(yearMap[hi] * 100) / 100 });
                    }
                }
            }

            const allSubs = saveSubmission(normalized);
            renderResults(allSubs, normalized);

            // Reset drawing state
            drawnPoints = [];
            smoothedPoints = [];
            mainChart.data.datasets[2].data = [];
            mainChart.update('none');
            updateButtons();

            // Scroll to results
            document.getElementById('results-section').scrollIntoView({ behavior: 'smooth', block: 'start' });
        });

        document.getElementById('clearDataBtn').addEventListener('click', () => {
            if (confirm('Clear all saved predictions? This cannot be undone.')) {
                clearAllSubmissions();
                document.getElementById('results-section').style.display = 'none';
                document.getElementById('statsGrid').innerHTML = '';
                if (resultsChart) {
                    resultsChart.destroy();
                    resultsChart = null;
                }
            }
        });

        // =====================================================================
        // 8. LOAD EXISTING SUBMISSIONS ON PAGE LOAD
        // =====================================================================
        const existing = loadSubmissions();
        if (existing.length > 0) {
            const lastSub = existing[existing.length - 1];
            renderResults(existing, lastSub.points);
        }

    })();
    </script>
</body>
</html>
