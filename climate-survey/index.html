<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climate Warming Trajectory Survey</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.0"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
        }

        header {
            text-align: center;
            padding: 2.5rem 1.5rem 1rem;
            max-width: 800px;
            margin: 0 auto;
        }

        header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #fff;
            letter-spacing: -0.02em;
        }

        header p {
            margin-top: 0.6rem;
            font-size: 0.95rem;
            color: #888;
            line-height: 1.5;
        }

        .section {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 1.5rem;
        }

        .chart-panel {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 1.25rem;
            margin-top: 1.5rem;
        }

        .chart-panel h2 {
            font-size: 1rem;
            font-weight: 600;
            color: #ccc;
            margin-bottom: 0.75rem;
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 440px;
        }

        .chart-container canvas {
            touch-action: none;
        }

        .instructions-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding: 0.6rem 0.75rem;
            background: rgba(0, 212, 255, 0.06);
            border: 1px solid rgba(0, 212, 255, 0.15);
            border-radius: 8px;
            font-size: 0.82rem;
            color: #8ecfdf;
        }

        .instructions-bar .icon { font-size: 1.1rem; flex-shrink: 0; }

        .controls {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.6rem 1.25rem;
            border: 1px solid #333;
            border-radius: 8px;
            background: #222;
            color: #ccc;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        button:hover:not(:disabled) {
            background: #2a2a2a;
            border-color: #555;
            color: #fff;
        }

        button:disabled { opacity: 0.35; cursor: not-allowed; }

        button.primary {
            background: #00a8cc;
            border-color: #00a8cc;
            color: #fff;
        }

        button.primary:hover:not(:disabled) {
            background: #00bde0;
            border-color: #00bde0;
        }

        #results-section {
            display: none;
            margin-top: 2rem;
            padding-bottom: 1rem;
        }

        .verdict-box {
            margin-top: 1.25rem;
            padding: 1.1rem 1.25rem;
            border-radius: 10px;
            border: 1px solid #2a2a2a;
            background: #141414;
        }

        .verdict-box h3 {
            font-size: 0.95rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.5rem;
        }

        .verdict-box .verdict-text {
            font-size: 0.88rem;
            line-height: 1.6;
            color: #aaa;
        }

        .verdict-box .verdict-text strong {
            color: #00d4ff;
        }

        .verdict-box .scenario-tag {
            display: inline-block;
            padding: 0.15em 0.5em;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .stat-card {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 0.85rem;
            text-align: center;
        }

        .stat-card .value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #00d4ff;
        }

        .stat-card .label {
            font-size: 0.72rem;
            color: #777;
            margin-top: 0.25rem;
        }

        .legend-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem 1.2rem;
            margin-top: 0.75rem;
            font-size: 0.75rem;
            color: #888;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .legend-swatch {
            width: 18px;
            height: 10px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        footer {
            text-align: center;
            padding: 2rem 1.5rem 3rem;
            font-size: 0.78rem;
            color: #555;
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.6;
        }

        footer a { color: #777; text-decoration: none; }
        footer a:hover { color: #aaa; text-decoration: underline; }

        @media (max-width: 600px) {
            header { padding: 1.5rem 1rem 0.5rem; }
            header h1 { font-size: 1.4rem; }
            .section { padding: 0 1rem; }
            .chart-container { height: 320px; }
            .controls { gap: 0.5rem; }
            button { padding: 0.5rem 0.9rem; font-size: 0.8rem; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <header>
        <h1>Climate Warming Trajectory Survey</h1>
        <p>How warm do you think the planet will get? Draw your prediction for global temperature anomaly from 2026 to 2100, based on historical observations.</p>
    </header>

    <div class="section">
        <div class="chart-panel">
            <h2>Global Temperature Anomaly (relative to 1850&ndash;1900 baseline)</h2>
            <div class="chart-container">
                <canvas id="mainChart"></canvas>
            </div>
            <div class="instructions-bar">
                <span class="icon">&#9998;</span>
                <span>Click and drag in the shaded area (2026&ndash;2100) to draw your predicted temperature trajectory. Your line can go up, down, or both.</span>
            </div>
            <div class="controls">
                <button id="clearBtn" disabled>Clear Drawing</button>
                <button id="submitBtn" class="primary" disabled>Submit Prediction</button>
            </div>
        </div>
    </div>

    <div class="section" id="results-section">
        <div class="chart-panel">
            <h2>Your Prediction vs. Climate Scenarios</h2>
            <div class="chart-container">
                <canvas id="resultsChart"></canvas>
            </div>
            <div class="legend-row" id="scenarioLegend"></div>
        </div>
        <div class="verdict-box" id="verdictBox"></div>
        <div class="stats-grid" id="statsGrid"></div>
    </div>

    <footer>
        Historical data: ERA5, Berkeley Earth, GISTEMP, HadCRUT5, JRA-3Q, NOAAGlobalTemp v6.<br>
        Scenario projections: IPCC AR6 WG1 SSP assessed ranges (CMIP6).<br>
        <a href="/">&#8592; Back to Home</a>
    </footer>

    <script>
    (function() {
        'use strict';

        // =====================================================================
        // 1. HISTORICAL DATA
        // =====================================================================
        const RAW = [
            [1850,null,-0.0364],[1851,null,0.0673],[1852,null,0.0897],[1853,null,0.0561],[1854,null,0.0603],
            [1855,null,0.0549],[1856,null,-0.0193],[1857,null,-0.1295],[1858,null,-0.0312],[1859,null,0.0863],
            [1860,null,-0.0611],[1861,null,-0.1185],[1862,null,-0.2127],[1863,null,-0.0222],[1864,null,-0.0725],
            [1865,null,0.0420],[1866,null,0.0474],[1867,null,0.0271],[1868,null,0.0338],[1869,null,0.0685],
            [1870,null,0.0089],[1871,null,-0.0131],[1872,null,-0.0003],[1873,null,0.0056],[1874,null,-0.0318],
            [1875,null,-0.0422],[1876,null,-0.0680],[1877,null,0.2864],[1878,null,0.3474],[1879,null,0.0477],
            [1880,0.0962,0.0305],[1881,0.1796,0.1226],[1882,0.1613,0.0694],[1883,0.0946,0.0194],
            [1884,-0.0146,-0.1140],[1885,-0.0629,-0.0839],[1886,-0.0471,-0.0987],[1887,-0.0971,-0.1519],
            [1888,0.0962,0.0363],[1889,0.1613,0.1303],[1890,-0.0854,-0.1451],[1891,0.0454,-0.0230],
            [1892,-0.0054,-0.0864],[1893,-0.0446,-0.1047],[1894,-0.0379,-0.0974],[1895,0.0396,-0.0394],
            [1896,0.1554,0.0957],[1897,0.1587,0.0978],[1898,-0.0054,-0.0789],[1899,0.0921,0.0445],
            [1900,0.1846,0.1498],[1901,0.1162,0.0864],[1902,-0.0112,-0.0498],[1903,-0.1004,-0.1552],
            [1904,-0.1979,-0.2273],[1905,0.0087,-0.0371],[1906,0.0537,0.0375],[1907,-0.1129,-0.1389],
            [1908,-0.1546,-0.1764],[1909,-0.2138,-0.2143],[1910,-0.1663,-0.1784],[1911,-0.1688,-0.1915],
            [1912,-0.0896,-0.1199],[1913,-0.0738,-0.1040],[1914,0.1171,0.0856],[1915,0.1279,0.1330],
            [1916,-0.0888,-0.0913],[1917,-0.1871,-0.2165],[1918,-0.0263,-0.0744],[1919,-0.0071,-0.0103],
            [1920,-0.0038,0.0110],[1921,0.0837,0.0766],[1922,-0.0129,-0.0110],[1923,0.0062,0.0042],
            [1924,0.0012,0.0069],[1925,0.0487,0.0434],[1926,0.1637,0.1797],[1927,0.0554,0.0727],
            [1928,0.0687,0.0873],[1929,-0.0888,-0.0848],[1930,0.1179,0.1295],[1931,0.1812,0.1940],
            [1932,0.1137,0.1377],[1933,-0.0112,-0.0153],[1934,0.1479,0.1332],[1935,0.0762,0.0799],
            [1936,0.1271,0.1295],[1937,0.2437,0.2614],[1938,0.2721,0.2747],[1939,0.2529,0.2600],
            [1940,0.1954,0.3238],[1941,0.2429,0.3624],[1942,0.1512,0.2678],[1943,0.1562,0.2821],
            [1944,0.3479,0.4451],[1945,0.2087,0.3316],[1946,0.2121,0.2002],[1947,0.2562,0.2143],
            [1948,0.1954,0.1824],[1949,0.2279,0.1820],[1950,0.1162,0.1005],[1951,0.2479,0.2425],
            [1952,0.2337,0.2888],[1953,0.3104,0.3644],[1954,0.1137,0.1681],[1955,0.0937,0.1253],
            [1956,0.0354,0.0690],[1957,0.2837,0.3044],[1958,0.3496,0.3341],[1959,0.3154,0.3017],
            [1960,0.2696,0.2477],[1961,0.3454,0.3172],[1962,0.2854,0.2848],[1963,0.3221,0.3079],
            [1964,0.1112,0.0566],[1965,0.1737,0.1624],[1966,0.2496,0.2161],[1967,0.2629,0.2448],
            [1968,0.2029,0.1897],[1969,0.3321,0.3242],[1970,0.3062,0.2847],[1971,0.1537,0.1647],
            [1972,0.2871,0.2772],[1973,0.3912,0.4114],[1974,0.1171,0.1843],[1975,0.1404,0.2200],
            [1976,0.0712,0.1473],[1977,0.3562,0.4225],[1978,0.2987,0.3317],[1979,0.4537,0.4347],
            [1980,0.5854,0.5407],[1981,0.6196,0.5907],[1982,0.4196,0.3963],[1983,0.6146,0.5804],
            [1984,0.4012,0.4059],[1985,0.3612,0.3790],[1986,0.4496,0.4548],[1987,0.6062,0.5958],
            [1988,0.6371,0.6374],[1989,0.5179,0.5242],[1990,0.7496,0.7159],[1991,0.6954,0.6786],
            [1992,0.4637,0.4730],[1993,0.5096,0.5114],[1994,0.5462,0.5718],[1995,0.7229,0.7270],
            [1996,0.5921,0.6119],[1997,0.7162,0.7438],[1998,0.9029,0.9049],[1999,0.6362,0.6599],
            [2000,0.6304,0.6636],[2001,0.7904,0.8086],[2002,0.8879,0.8874],[2003,0.8737,0.8808],
            [2004,0.8137,0.8049],[2005,0.9762,0.9576],[2006,0.9279,0.9104],[2007,0.9196,0.9148],
            [2008,0.7871,0.7930],[2009,0.9179,0.9199],[2010,1.0137,0.9998],[2011,0.8712,0.8770],
            [2012,0.9221,0.9124],[2013,0.9504,0.9472],[2014,0.9896,1.0046],[2015,1.1396,1.1547],
            [2016,1.3237,1.2941],[2017,1.2271,1.1961],[2018,1.1462,1.1183],[2019,1.2837,1.2478],
            [2020,1.3162,1.2814],[2021,1.1562,1.1145],[2022,1.1846,1.1564],[2023,1.4837,1.4528],
            [2024,1.6027,1.5523]
        ];

        const HIST_YEARS = [], ERA5 = [], MULTI_MEAN = [];
        for (const row of RAW) {
            HIST_YEARS.push(row[0]);
            ERA5.push(row[1]);
            MULTI_MEAN.push(row[2]);
        }

        const LAST_HIST_YEAR = 2024;
        const LAST_ERA5_TEMP = 1.6027;
        const PREDICT_START = 2026;
        const PREDICT_END = 2100;

        // =====================================================================
        // 2. SSP SCENARIO DATA (IPCC AR6 WG1, CMIP6 multi-model)
        //    Best-estimate (mean) and likely range (5-95th percentile)
        //    Anomaly relative to 1850-1900 baseline
        // =====================================================================
        const SSP_YEARS = [2026, 2030, 2040, 2050, 2060, 2070, 2080, 2090, 2100];

        const SSP = {
            'SSP1-2.6': {
                mean: [1.45, 1.50, 1.60, 1.70, 1.70, 1.75, 1.80, 1.80, 1.80],
                lo:   [1.20, 1.20, 1.25, 1.30, 1.25, 1.25, 1.25, 1.20, 1.20],
                hi:   [1.70, 1.80, 2.00, 2.15, 2.20, 2.25, 2.30, 2.35, 2.40],
                color: 'rgba(76,153,76,1)',
                fill:  'rgba(76,153,76,0.15)',
                label: 'SSP1-2.6 (strong mitigation)'
            },
            'SSP2-4.5': {
                mean: [1.45, 1.50, 1.65, 1.90, 2.10, 2.30, 2.50, 2.65, 2.70],
                lo:   [1.20, 1.20, 1.30, 1.45, 1.55, 1.65, 1.80, 1.85, 1.90],
                hi:   [1.70, 1.85, 2.10, 2.50, 2.80, 3.10, 3.40, 3.60, 3.70],
                color: 'rgba(80,120,190,1)',
                fill:  'rgba(80,120,190,0.15)',
                label: 'SSP2-4.5 (moderate)'
            },
            'SSP3-7.0': {
                mean: [1.45, 1.50, 1.70, 2.00, 2.30, 2.70, 3.10, 3.40, 3.60],
                lo:   [1.20, 1.20, 1.35, 1.55, 1.75, 2.00, 2.25, 2.45, 2.55],
                hi:   [1.75, 1.85, 2.15, 2.60, 3.10, 3.60, 4.15, 4.55, 4.85],
                color: 'rgba(170,100,140,1)',
                fill:  'rgba(170,100,140,0.15)',
                label: 'SSP3-7.0 (high emissions)'
            },
            'SSP5-8.5': {
                mean: [1.50, 1.60, 1.85, 2.20, 2.65, 3.15, 3.70, 4.10, 4.40],
                lo:   [1.25, 1.30, 1.45, 1.70, 2.00, 2.30, 2.70, 2.95, 3.10],
                hi:   [1.80, 1.95, 2.35, 2.90, 3.55, 4.25, 5.00, 5.55, 5.90],
                color: 'rgba(190,80,80,1)',
                fill:  'rgba(190,80,80,0.15)',
                label: 'SSP5-8.5 (very high emissions)'
            }
        };

        // Interpolate SSP data to every integer year
        function interpSSP(arr) {
            const out = {};
            for (let i = 0; i < SSP_YEARS.length - 1; i++) {
                const y0 = SSP_YEARS[i], y1 = SSP_YEARS[i + 1];
                const v0 = arr[i], v1 = arr[i + 1];
                for (let y = y0; y < y1; y++) {
                    out[y] = v0 + (v1 - v0) * (y - y0) / (y1 - y0);
                }
            }
            out[SSP_YEARS[SSP_YEARS.length - 1]] = arr[arr.length - 1];
            return out;
        }

        const SSP_INTERP = {};
        for (const [key, val] of Object.entries(SSP)) {
            SSP_INTERP[key] = {
                mean: interpSSP(val.mean),
                lo: interpSSP(val.lo),
                hi: interpSSP(val.hi)
            };
        }

        // =====================================================================
        // 3. MAIN CHART
        // =====================================================================
        const mainCtx = document.getElementById('mainChart').getContext('2d');

        const era5Data = [], multiData = [];
        for (let i = 0; i < HIST_YEARS.length; i++) {
            if (ERA5[i] !== null) era5Data.push({ x: HIST_YEARS[i], y: ERA5[i] });
            multiData.push({ x: HIST_YEARS[i], y: MULTI_MEAN[i] });
        }

        const predictionZonePlugin = {
            id: 'predictionZone',
            beforeDatasetsDraw(chart) {
                const ctx = chart.ctx;
                const xScale = chart.scales.x;
                const left = xScale.getPixelForValue(PREDICT_START);
                const right = xScale.getPixelForValue(PREDICT_END);
                const top = chart.chartArea.top;
                const bottom = chart.chartArea.bottom;
                ctx.save();
                ctx.fillStyle = 'rgba(255,255,255,0.03)';
                ctx.fillRect(left, top, right - left, bottom - top);
                ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(left, top);
                ctx.lineTo(left, bottom);
                ctx.stroke();
                ctx.restore();
            }
        };

        let drawnPoints = [];
        let smoothedPoints = [];
        let isDrawing = false;

        const mainChart = new Chart(mainCtx, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: 'Multi-dataset Mean',
                        data: multiData,
                        borderColor: 'rgba(150,150,150,0.35)',
                        borderWidth: 1.2,
                        pointRadius: 0, pointHitRadius: 0,
                        tension: 0.3, order: 3
                    },
                    {
                        label: 'ERA5',
                        data: era5Data,
                        borderColor: '#ff6b35',
                        borderWidth: 2,
                        pointRadius: 0, pointHitRadius: 0,
                        tension: 0.1, order: 2
                    },
                    {
                        label: 'Your Prediction',
                        data: [],
                        borderColor: '#00d4ff',
                        borderWidth: 2.5,
                        pointRadius: 0, pointHitRadius: 0,
                        tension: 0, order: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: { mode: 'nearest', intersect: false },
                scales: {
                    x: {
                        type: 'linear',
                        min: 1850, max: 2100,
                        ticks: {
                            stepSize: 25,
                            color: '#666',
                            font: { size: 11 },
                            callback: v => String(Math.round(v))
                        },
                        grid: { color: 'rgba(255,255,255,0.05)' },
                        title: { display: true, text: 'Year', color: '#777', font: { size: 12 } }
                    },
                    y: {
                        min: -0.5, max: 5.0,
                        ticks: {
                            stepSize: 0.5, color: '#666', font: { size: 11 },
                            callback: v => v.toFixed(1) + '\u00B0C'
                        },
                        grid: { color: 'rgba(255,255,255,0.05)' },
                        title: { display: true, text: 'Temperature Anomaly (\u00B0C)', color: '#777', font: { size: 12 } }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#999', font: { size: 11 },
                            usePointStyle: true, pointStyle: 'line', padding: 16
                        }
                    },
                    annotation: {
                        annotations: {
                            line15: {
                                type: 'line', yMin: 1.5, yMax: 1.5,
                                borderColor: 'rgba(251,191,36,0.5)', borderWidth: 1.5, borderDash: [6, 4],
                                label: { display: true, content: '1.5\u00B0C', position: 'start', backgroundColor: 'rgba(251,191,36,0.15)', color: '#fbbf24', font: { size: 10 }, padding: 3 }
                            },
                            line20: {
                                type: 'line', yMin: 2.0, yMax: 2.0,
                                borderColor: 'rgba(239,68,68,0.5)', borderWidth: 1.5, borderDash: [6, 4],
                                label: { display: true, content: '2.0\u00B0C', position: 'start', backgroundColor: 'rgba(239,68,68,0.15)', color: '#ef4444', font: { size: 10 }, padding: 3 }
                            }
                        }
                    },
                    tooltip: { enabled: false }
                }
            },
            plugins: [predictionZonePlugin]
        });

        // =====================================================================
        // 4. DRAWING INTERACTION
        // =====================================================================
        const canvas = mainChart.canvas;
        const clearBtn = document.getElementById('clearBtn');
        const submitBtn = document.getElementById('submitBtn');

        function getCanvasPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0)
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function pixelToData(px, py) {
            return {
                year: mainChart.scales.x.getValueForPixel(px),
                temp: mainChart.scales.y.getValueForPixel(py)
            };
        }

        function isInPredictZone(px) {
            const left = mainChart.scales.x.getPixelForValue(PREDICT_START);
            const right = mainChart.scales.x.getPixelForValue(PREDICT_END);
            return px >= left - 5 && px <= right + 5;
        }

        function clampData(year, temp) {
            return {
                year: Math.max(PREDICT_START, Math.min(PREDICT_END, year)),
                temp: Math.max(-0.5, Math.min(5.0, temp))
            };
        }

        function updatePredictionDataset(pts) {
            const anchor = { x: LAST_HIST_YEAR, y: LAST_ERA5_TEMP };
            mainChart.data.datasets[2].data = [anchor, ...pts.map(p => ({ x: p.year, y: p.temp }))];
            mainChart.update('none');
        }

        function updateButtons() {
            const hasDrawn = drawnPoints.length > 5;
            clearBtn.disabled = !hasDrawn;
            if (hasDrawn) {
                const maxYear = Math.max(...drawnPoints.map(p => p.year));
                submitBtn.disabled = maxYear < 2085;
            } else {
                submitBtn.disabled = true;
            }
        }

        function onDrawStart(e) {
            const pos = getCanvasPos(e);
            if (!isInPredictZone(pos.x)) return;
            if (e.cancelable) e.preventDefault();
            isDrawing = true;
            drawnPoints = [];
            smoothedPoints = [];
            const d = clampData(...Object.values(pixelToData(pos.x, pos.y)));
            drawnPoints.push(d);
            updatePredictionDataset(drawnPoints);
        }

        function onDrawMove(e) {
            if (!isDrawing) return;
            if (e.cancelable) e.preventDefault();
            const pos = getCanvasPos(e);
            const d = clampData(...Object.values(pixelToData(pos.x, pos.y)));
            drawnPoints.push(d);
            updatePredictionDataset(drawnPoints);
            updateButtons();
        }

        function onDrawEnd() {
            if (!isDrawing) return;
            isDrawing = false;
            updateButtons();
        }

        canvas.addEventListener('mousedown', onDrawStart);
        canvas.addEventListener('mousemove', onDrawMove);
        canvas.addEventListener('mouseup', onDrawEnd);
        canvas.addEventListener('mouseleave', onDrawEnd);
        canvas.addEventListener('touchstart', onDrawStart, { passive: false });
        canvas.addEventListener('touchmove', onDrawMove, { passive: false });
        canvas.addEventListener('touchend', onDrawEnd);
        canvas.addEventListener('touchcancel', onDrawEnd);

        // =====================================================================
        // 5. SMOOTHING (cubic spline)
        // =====================================================================
        function downsampleByYear(points, numBuckets) {
            if (points.length === 0) return [];
            const minY = PREDICT_START, maxY = PREDICT_END;
            const bw = (maxY - minY) / numBuckets;
            const buckets = Array.from({ length: numBuckets }, () => []);
            for (const p of points) {
                const idx = Math.min(numBuckets - 1, Math.max(0, Math.floor((p.year - minY) / bw)));
                buckets[idx].push(p.temp);
            }
            const cps = [];
            for (let i = 0; i < numBuckets; i++) {
                if (buckets[i].length > 0) {
                    const sorted = buckets[i].slice().sort((a, b) => a - b);
                    cps.push({ year: minY + (i + 0.5) * bw, temp: sorted[Math.floor(sorted.length / 2)] });
                }
            }
            return cps;
        }

        function naturalCubicSpline(pts) {
            const n = pts.length - 1;
            if (n < 1) return () => pts[0] ? pts[0].temp : 0;
            const x = pts.map(p => p.year), y = pts.map(p => p.temp);
            const h = [];
            for (let i = 0; i < n; i++) h.push(x[i + 1] - x[i]);
            if (n === 1) return t => { const f = (t - x[0]) / (x[1] - x[0]); return y[0] + f * (y[1] - y[0]); };

            const alpha = [];
            for (let i = 1; i < n; i++) alpha.push(3 / h[i] * (y[i + 1] - y[i]) - 3 / h[i - 1] * (y[i] - y[i - 1]));

            const l = new Array(n + 1).fill(1), mu = new Array(n + 1).fill(0), z = new Array(n + 1).fill(0);
            for (let i = 1; i < n; i++) {
                l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
                mu[i] = h[i] / l[i];
                z[i] = (alpha[i - 1] - h[i - 1] * z[i - 1]) / l[i];
            }

            const c = new Array(n + 1).fill(0), b = new Array(n).fill(0), d = new Array(n).fill(0);
            for (let j = n - 1; j >= 0; j--) {
                c[j] = z[j] - mu[j] * c[j + 1];
                b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
                d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
            }

            return function(t) {
                let i = 0;
                for (i = 0; i < n - 1; i++) { if (t < x[i + 1]) break; }
                const dx = t - x[i];
                return y[i] + b[i] * dx + c[i] * dx * dx + d[i] * dx * dx * dx;
            };
        }

        function isInjective(pts) {
            // Check if x-values (years) are strictly increasing
            for (let i = 1; i < pts.length; i++) {
                if (pts[i].year <= pts[i - 1].year) return false;
            }
            return true;
        }

        function smoothDrawing() {
            if (drawnPoints.length < 3) return false;
            let cps = downsampleByYear(drawnPoints, 30);
            if (cps.length < 2) return false;
            cps.sort((a, b) => a.year - b.year);
            if (cps[0].year > PREDICT_START + 2) cps.unshift({ year: PREDICT_START, temp: LAST_ERA5_TEMP });
            const fn = naturalCubicSpline(cps);
            if (typeof fn !== 'function') return false;
            smoothedPoints = [];
            for (let yr = PREDICT_START; yr <= PREDICT_END; yr++) {
                let t = fn(yr);
                t = Math.max(-0.5, Math.min(5.0, t));
                smoothedPoints.push({ year: yr, temp: Math.round(t * 100) / 100 });
            }
            updatePredictionDataset(smoothedPoints);
            drawnPoints = smoothedPoints.slice();
            updateButtons();
            return true;
        }

        // =====================================================================
        // 6. LOCALSTORAGE
        // =====================================================================
        const STORAGE_KEY = 'climate-survey-submissions';

        function loadSubmissions() {
            try { const r = localStorage.getItem(STORAGE_KEY); return r ? JSON.parse(r) : []; }
            catch { return []; }
        }

        function saveSubmission(points) {
            const subs = loadSubmissions();
            subs.push({
                id: Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
                timestamp: new Date().toISOString(),
                points: points
            });
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(subs)); } catch {}
            return subs;
        }

        // =====================================================================
        // 7. NORMALIZE + SUBMIT
        // =====================================================================
        function normalizePoints(pts) {
            const yearMap = {};
            for (const p of pts) {
                const yr = Math.round(p.year);
                if (yr >= PREDICT_START && yr <= PREDICT_END) yearMap[yr] = p.temp;
            }
            const years = Object.keys(yearMap).map(Number).sort((a, b) => a - b);
            if (years.length < 2) return null;

            const result = [];
            for (let yr = PREDICT_START; yr <= PREDICT_END; yr++) {
                if (yearMap[yr] !== undefined) {
                    result.push({ year: yr, temp: Math.round(yearMap[yr] * 100) / 100 });
                } else {
                    let lo = null, hi = null;
                    for (const fy of years) { if (fy <= yr) lo = fy; if (fy >= yr && hi === null) hi = fy; }
                    if (lo !== null && hi !== null && lo !== hi) {
                        const frac = (yr - lo) / (hi - lo);
                        result.push({ year: yr, temp: Math.round((yearMap[lo] + frac * (yearMap[hi] - yearMap[lo])) * 100) / 100 });
                    } else if (lo !== null) {
                        result.push({ year: yr, temp: Math.round(yearMap[lo] * 100) / 100 });
                    } else if (hi !== null) {
                        result.push({ year: yr, temp: Math.round(yearMap[hi] * 100) / 100 });
                    }
                }
            }
            return result;
        }

        // =====================================================================
        // 8. SSP COMPARISON & PERCENTILE
        // =====================================================================
        function computeSSPPercentile(userPoints) {
            // For each year, figure out where the user sits in the SSP range
            // We'll use the 2100 value primarily, but also compute an average position
            const user2100 = userPoints.find(p => p.year === 2100);
            if (!user2100) return null;

            const uTemp = user2100.temp;

            // SSP best estimates at 2100: 1.8, 2.7, 3.6, 4.4
            // Full range lo to hi at 2100: 1.2 to 5.9
            const scenarios = [
                { name: 'SSP1-2.6', mean: 1.80, lo: 1.20, hi: 2.40 },
                { name: 'SSP2-4.5', mean: 2.70, lo: 1.90, hi: 3.70 },
                { name: 'SSP3-7.0', mean: 3.60, lo: 2.55, hi: 4.85 },
                { name: 'SSP5-8.5', mean: 4.40, lo: 3.10, hi: 5.90 }
            ];

            // Find closest scenario
            let closestScenario = scenarios[0];
            let closestDist = Math.abs(uTemp - scenarios[0].mean);
            for (const s of scenarios) {
                const dist = Math.abs(uTemp - s.mean);
                if (dist < closestDist) { closestDist = dist; closestScenario = s; }
            }

            // Compute a percentile across the full SSP range
            // Below SSP1-2.6 lo = very optimistic (0%), above SSP5-8.5 hi = very pessimistic (100%)
            const absLo = 1.20; // SSP1-2.6 5th percentile at 2100
            const absHi = 5.90; // SSP5-8.5 95th percentile at 2100
            let percentile = (uTemp - absLo) / (absHi - absLo) * 100;
            percentile = Math.max(0, Math.min(100, Math.round(percentile)));

            // Determine label
            let outlook;
            if (percentile <= 15) outlook = 'very optimistic';
            else if (percentile <= 35) outlook = 'optimistic';
            else if (percentile <= 65) outlook = 'moderate';
            else if (percentile <= 85) outlook = 'pessimistic';
            else outlook = 'very pessimistic';

            return { percentile, outlook, closestScenario, temp2100: uTemp };
        }

        // =====================================================================
        // 9. RESULTS CHART
        // =====================================================================
        let resultsChart = null;

        function renderResults(submissions, latestPoints) {
            const section = document.getElementById('results-section');
            if (!latestPoints && submissions.length === 0) { section.style.display = 'none'; return; }
            section.style.display = 'block';

            // Compute community envelope and mean
            const envelopeMin = [], envelopeMax = [], meanLine = [];
            for (let yr = PREDICT_START; yr <= PREDICT_END; yr++) {
                const temps = [];
                for (const sub of submissions) {
                    const pt = sub.points.find(p => p.year === yr);
                    if (pt) temps.push(pt.temp);
                }
                if (temps.length > 0) {
                    envelopeMin.push({ x: yr, y: Math.min(...temps) });
                    envelopeMax.push({ x: yr, y: Math.max(...temps) });
                    meanLine.push({ x: yr, y: temps.reduce((a, b) => a + b, 0) / temps.length });
                }
            }

            const latestData = latestPoints
                ? [{ x: LAST_HIST_YEAR, y: LAST_ERA5_TEMP }, ...latestPoints.map(p => ({ x: p.year, y: p.temp }))]
                : [];

            // Build SSP band datasets
            const sspDatasets = [];
            const sspOrder = ['SSP1-2.6', 'SSP2-4.5', 'SSP3-7.0', 'SSP5-8.5'];

            for (const key of sspOrder) {
                const s = SSP[key];
                const interp = SSP_INTERP[key];
                const hiData = [], loData = [], meanData = [];
                for (let yr = PREDICT_START; yr <= PREDICT_END; yr++) {
                    hiData.push({ x: yr, y: interp.hi[yr] });
                    loData.push({ x: yr, y: interp.lo[yr] });
                    meanData.push({ x: yr, y: interp.mean[yr] });
                }

                // Shaded band (hi fills down to lo)
                sspDatasets.push({
                    label: key + ' range (hi)',
                    data: hiData,
                    borderColor: 'transparent',
                    backgroundColor: s.fill,
                    borderWidth: 0, pointRadius: 0,
                    fill: '+1',
                    order: 10
                });
                sspDatasets.push({
                    label: key + ' range (lo)',
                    data: loData,
                    borderColor: 'transparent',
                    borderWidth: 0, pointRadius: 0,
                    fill: false,
                    order: 10
                });
                // Mean line
                sspDatasets.push({
                    label: key,
                    data: meanData,
                    borderColor: s.color.replace(',1)', ',0.6)'),
                    borderWidth: 1.5,
                    borderDash: [3, 3],
                    pointRadius: 0,
                    tension: 0.3,
                    order: 8
                });
            }

            // Full dataset list
            const datasets = [
                // Historical
                {
                    label: 'Multi-dataset Mean',
                    data: multiData,
                    borderColor: 'rgba(150,150,150,0.3)',
                    borderWidth: 1, pointRadius: 0, tension: 0.3, order: 12
                },
                {
                    label: 'ERA5 (Historical)',
                    data: era5Data,
                    borderColor: 'rgba(60,60,60,0.9)',
                    borderWidth: 2, pointRadius: 0, tension: 0.1, order: 6
                },
                // SSP bands
                ...sspDatasets,
            ];

            // Community envelope (only if multiple submissions)
            if (submissions.length > 1) {
                datasets.push({
                    label: 'Community Range (max)',
                    data: envelopeMax,
                    borderColor: 'transparent',
                    backgroundColor: 'rgba(0, 212, 255, 0.08)',
                    borderWidth: 0, pointRadius: 0,
                    fill: '+1', order: 5
                });
                datasets.push({
                    label: 'Community Range (min)',
                    data: envelopeMin,
                    borderColor: 'transparent',
                    borderWidth: 0, pointRadius: 0,
                    fill: false, order: 5
                });
                datasets.push({
                    label: 'Community Mean',
                    data: meanLine,
                    borderColor: 'rgba(0, 212, 255, 0.5)',
                    borderWidth: 1.5, borderDash: [4, 3],
                    pointRadius: 0, tension: 0.2, order: 3
                });
            }

            // User's latest
            if (latestData.length > 0) {
                datasets.push({
                    label: 'Your Prediction',
                    data: latestData,
                    borderColor: '#00d4ff',
                    borderWidth: 3, pointRadius: 0,
                    tension: 0.1, order: 1
                });
            }

            if (resultsChart) resultsChart.destroy();
            const rCtx = document.getElementById('resultsChart').getContext('2d');
            resultsChart = new Chart(rCtx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 400 },
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: {
                            type: 'linear', min: 1850, max: 2100,
                            ticks: {
                                stepSize: 25, color: '#666', font: { size: 11 },
                                callback: v => String(Math.round(v))
                            },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            title: { display: true, text: 'Year', color: '#777', font: { size: 12 } }
                        },
                        y: {
                            min: -0.5, max: 6.0,
                            ticks: {
                                stepSize: 0.5, color: '#666', font: { size: 11 },
                                callback: v => v.toFixed(1) + '\u00B0C'
                            },
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            title: { display: true, text: 'Temperature Anomaly (\u00B0C)', color: '#777', font: { size: 12 } }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: {
                            annotations: {
                                line15: {
                                    type: 'line', yMin: 1.5, yMax: 1.5,
                                    borderColor: 'rgba(251,191,36,0.35)', borderWidth: 1, borderDash: [6, 4],
                                    label: { display: true, content: '1.5\u00B0C', position: 'start', backgroundColor: 'rgba(251,191,36,0.1)', color: 'rgba(251,191,36,0.6)', font: { size: 9 }, padding: 2 }
                                },
                                line20: {
                                    type: 'line', yMin: 2.0, yMax: 2.0,
                                    borderColor: 'rgba(239,68,68,0.35)', borderWidth: 1, borderDash: [6, 4],
                                    label: { display: true, content: '2.0\u00B0C', position: 'start', backgroundColor: 'rgba(239,68,68,0.1)', color: 'rgba(239,68,68,0.6)', font: { size: 9 }, padding: 2 }
                                }
                            }
                        },
                        tooltip: {
                            filter: item => !item.dataset.label.includes('range') && !item.dataset.label.includes('(min)') && !item.dataset.label.includes('(max)') && !item.dataset.label.includes('Multi-dataset'),
                            callbacks: {
                                title: items => items.length > 0 ? String(Math.round(items[0].parsed.x)) : '',
                                label: item => item.dataset.label + ': ' + item.parsed.y.toFixed(2) + '\u00B0C'
                            }
                        }
                    }
                },
                plugins: [predictionZonePlugin]
            });

            // Custom legend
            renderScenarioLegend();

            // Verdict
            if (latestPoints) {
                renderVerdict(latestPoints, submissions);
            }

            // Stats
            renderStats(submissions, meanLine, latestPoints);
        }

        function renderScenarioLegend() {
            const el = document.getElementById('scenarioLegend');
            const items = [
                { label: 'Historical', color: 'rgba(60,60,60,0.9)', type: 'line' },
                { label: 'SSP1-2.6', color: SSP['SSP1-2.6'].color, bg: SSP['SSP1-2.6'].fill },
                { label: 'SSP2-4.5', color: SSP['SSP2-4.5'].color, bg: SSP['SSP2-4.5'].fill },
                { label: 'SSP3-7.0', color: SSP['SSP3-7.0'].color, bg: SSP['SSP3-7.0'].fill },
                { label: 'SSP5-8.5', color: SSP['SSP5-8.5'].color, bg: SSP['SSP5-8.5'].fill },
                { label: 'Your Prediction', color: '#00d4ff', type: 'line' }
            ];
            el.innerHTML = items.map(it => {
                const style = it.bg
                    ? `background:${it.bg}; border: 1.5px solid ${it.color.replace(',1)', ',0.6)')};`
                    : `background:${it.color};`;
                return `<div class="legend-item"><span class="legend-swatch" style="${style}"></span>${it.label}</div>`;
            }).join('');
        }

        function renderVerdict(latestPoints, submissions) {
            const box = document.getElementById('verdictBox');
            const result = computeSSPPercentile(latestPoints);
            if (!result) { box.innerHTML = ''; return; }

            const { percentile, outlook, closestScenario, temp2100 } = result;
            const scenarioColors = {
                'SSP1-2.6': { bg: 'rgba(76,153,76,0.15)', border: 'rgba(76,153,76,0.5)', text: '#6abf6a' },
                'SSP2-4.5': { bg: 'rgba(80,120,190,0.15)', border: 'rgba(80,120,190,0.5)', text: '#7099cc' },
                'SSP3-7.0': { bg: 'rgba(170,100,140,0.15)', border: 'rgba(170,100,140,0.5)', text: '#c088a8' },
                'SSP5-8.5': { bg: 'rgba(190,80,80,0.15)', border: 'rgba(190,80,80,0.5)', text: '#d07070' }
            };
            const sc = scenarioColors[closestScenario.name] || scenarioColors['SSP2-4.5'];

            box.innerHTML = `
                <h3>Your Outlook</h3>
                <div class="verdict-text">
                    You predict <strong>${temp2100.toFixed(2)}\u00B0C</strong> of warming by 2100, which is closest to
                    <span class="scenario-tag" style="background:${sc.bg}; border:1px solid ${sc.border}; color:${sc.text}">${closestScenario.name}</span>
                    (best estimate: ${closestScenario.mean.toFixed(1)}\u00B0C).<br><br>
                    Your prediction falls in the <strong>${percentile}th percentile</strong> across the full range of IPCC scenarios &mdash;
                    placing you in the <strong>${outlook}</strong> camp.
                    ${percentile <= 30
                        ? 'You expect strong global mitigation efforts to succeed in limiting warming.'
                        : percentile <= 60
                        ? 'You expect moderate policy action with continued warming through mid-century.'
                        : 'You expect emissions to remain high with substantial warming by end of century.'}
                    ${submissions.length > 1
                        ? `<br><br>Out of <strong>${submissions.length}</strong> predictions recorded, the community average at 2100 is <strong>${(submissions.reduce((s, sub) => { const p = sub.points.find(p => p.year === 2100); return s + (p ? p.temp : 0); }, 0) / submissions.length).toFixed(2)}\u00B0C</strong>.`
                        : ''}
                </div>
            `;
        }

        function renderStats(submissions, meanLine, latestPoints) {
            const grid = document.getElementById('statsGrid');
            const count = submissions.length;
            const lastMean = meanLine.length > 0 ? meanLine[meanLine.length - 1].y : null;

            let cross15 = null, cross20 = null;
            for (const pt of meanLine) {
                if (cross15 === null && pt.y >= 1.5) cross15 = Math.round(pt.x);
                if (cross20 === null && pt.y >= 2.0) cross20 = Math.round(pt.x);
            }

            const userTemp = latestPoints ? latestPoints.find(p => p.year === 2100) : null;

            grid.innerHTML = `
                <div class="stat-card">
                    <div class="value">${count}</div>
                    <div class="label">Total Predictions</div>
                </div>
                <div class="stat-card">
                    <div class="value">${userTemp ? userTemp.temp.toFixed(2) + '\u00B0C' : '\u2014'}</div>
                    <div class="label">Your 2100 Prediction</div>
                </div>
                <div class="stat-card">
                    <div class="value">${lastMean !== null && count > 1 ? lastMean.toFixed(2) + '\u00B0C' : '\u2014'}</div>
                    <div class="label">Community Mean at 2100</div>
                </div>
                <div class="stat-card">
                    <div class="value">${cross20 && count > 1 ? cross20 : '\u2014'}</div>
                    <div class="label">Mean Crosses 2.0\u00B0C</div>
                </div>
            `;
        }

        // =====================================================================
        // 10. BUTTON HANDLERS
        // =====================================================================
        clearBtn.addEventListener('click', () => {
            drawnPoints = [];
            smoothedPoints = [];
            mainChart.data.datasets[2].data = [];
            mainChart.update('none');
            updateButtons();
        });

        submitBtn.addEventListener('click', () => {
            // Auto-smooth if the drawn input is not injective (has backwards x)
            if (!isInjective(drawnPoints) || smoothedPoints.length === 0) {
                smoothDrawing();
            }

            const pts = smoothedPoints.length > 0 ? smoothedPoints : drawnPoints;
            if (pts.length === 0) return;

            const normalized = normalizePoints(pts);
            if (!normalized || normalized.length < 10) return;

            const allSubs = saveSubmission(normalized);
            renderResults(allSubs, normalized);

            // Reset drawing
            drawnPoints = [];
            smoothedPoints = [];
            mainChart.data.datasets[2].data = [];
            mainChart.update('none');
            updateButtons();

            document.getElementById('results-section').scrollIntoView({ behavior: 'smooth', block: 'start' });
        });

        // =====================================================================
        // 11. LOAD EXISTING ON PAGE LOAD
        // =====================================================================
        const existing = loadSubmissions();
        if (existing.length > 0) {
            const last = existing[existing.length - 1];
            renderResults(existing, last.points);
        }

    })();
    </script>
</body>
</html>
